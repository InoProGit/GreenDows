<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
    <div id="animated" style="position: absolute;left: 549.5px;">Hello there.</div>
    <button onclick="start()">Start</button>
    <button onclick="stop()">Stop</button>
        <script type="text/javascript">
            var elm = document.getElementById("animated");
            var stopped;
            var requestId = 0;
            var starttime;
    
            function render(time) {
                // set left style to a function of time.
              if (!stopped) {
                elm.style.left = ((Date.now() - starttime) / 4 % 600) + "px";
                requestId = window.requestAnimationFrame(render);
                }
                if (parseInt(elm.style.left) > 300) {
                    stop();
                }
            }
    
            function start() {
                starttime = Date.now();
                requestId = window.requestAnimationFrame(render);
                stopped = false;
            }
            function stop() {
                if (requestId) {
                    window.cancelAnimationFrame(requestId);
                }
                stopped = true;
            }
    </script>
    <!-- <div id="triger">Click here</div> -->
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div id="taskbar-inner">
                <div class="taskbar-item-empty">
                    This is a taskbar, open menu and start your task...
                </div>
            </div>
        </div>
        <div id="taskbar-overlay"></div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// object with functions to init window interface
let functionsToInitWindow = {};
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
function initRadar( number = 5 ) {
    spawnRadar(radarToDecard(spawnRadarVals(number)));
}
functionsToInitWindow['initRadar'] = initRadar;
//

// render matrix on submit button in task window
function initFormMatrixSubmit() {
    let form = document.getElementById("matrix-form");
    form.onsubmit = function () {
        let number = document.getElementById("matrix_size").value;
        spawnRadar( radarToDecard( spawnRadarVals(number) ) );
        document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
        return false;
    };
}

functionsToInitWindow['initFormMatrixSubmit'] = initFormMatrixSubmit;
//

// helpers START

// function blocker clicks on active animation
function blockClicked ( element = {}, time = 0 ) {
    element.classList.add("blocked");
    let blockedTimeOut = setTimeout(() => {
        element.classList.remove("blocked");
    }, time);
}
//

// checking object for emptiness
function isEmptyObject ( rest = {} ) {
    return ( Object.keys(rest).length === 0 && rest.constructor === Object ) ?  true : false;
}
//

// checking unexpected params in function, if have throw error
function unexpectedParams(rest) {
    if ( !isEmptyObject(rest) ) throw new TypeError( message = `
Unexpected params given: ` + JSON.stringify(rest) + ` .
Make params align with expectations.` );
}
//

// hang any function onClick by selector
function forEachClick (
    {
        selector          = '',
        func              = Function,
        needTimeOut       = false,
        secTimeOut        = 0,
        selectorToBlocked = '',
        ...rest
    }
) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or u pass not a Function");
        if ( typeof needTimeOut !== 'boolean' ) throw new TypeError("U pass not Boolean in 'needTimeOut'");
        if ( typeof secTimeOut !== 'number' ) throw new TypeError("U pass not Number in 'secTimeOut'");
        if ( secTimeOut < 0 ) throw new TypeError("Ur Number - 'secTimeOut' is lower then 0");
        if ( needTimeOut !== false && typeof selectorToBlocked !== 'string' ||
             needTimeOut !== false && selectorToBlocked === '' ||
             needTimeOut !== false && !document.querySelectorAll(selectorToBlocked)[0]
            ) throw new ReferenceError("U pass not String in 'selectorToBlocked' or it wasn't found");
        unexpectedParams(rest);

        [].forEach.call( document.querySelectorAll(selector), function(element) {
            element.onclick = function(event) {
                if ( element.classList.contains("blocked") || element.closest(".blocked") === null ) {
                    func(this, event);
                    if ( needTimeOut ) {
                        blockClicked(document.querySelectorAll(selectorToBlocked)[0], secTimeOut);
                    }
                }
            }
        });
    } catch (err) {
        console.error(err);
    }
}
//

// hang any function by selector
function forEachFunc ( selector = '', func = Function ) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or it's not a Function");

        document.querySelectorAll(selector).forEach( function(element) {
            func(element);
        });
    } catch (err) {
        console.error(err);
    }
}
//

// array with selectors and functions when click outside it, hanged on document event click
let outsideElements = [];

function setOutsideClick ( selector = '', parent = '', funCall = Function ) {
    try {
        if ( typeof selector !== 'string' ) throw new TypeError("U pass not String in 'selector'");
        if ( typeof parent !== 'string' ) throw new TypeError("U pass not String in 'parent'");
        if (!document.querySelectorAll(selector)[0]) throw new ReferenceError("Ur 'selector' wasn't found");
        if (!document.querySelectorAll(parent)[0]) throw new ReferenceError("Ur 'parent' wasn't found");
        if ( funCall == Function || typeof funCall !== 'function') throw new TypeError("U didn't pass the 'funCall', or u pass not a Function");

        outsideElements.push({
            selector: selector,
            parent: parent,
            funCall: funCall
        });
        
    } catch (err) {
        console.error(err);
    }
}

function clickOutside ( outsideElements = [] ) {
    outsideElements.forEach( function(element) {
        if ( document.querySelectorAll(element.selector)[0].classList.contains("active") && !event.target.closest(element.parent) ) {
            element.funCall();
            console.warn('click outside element in array');
        }
    });
}

document.addEventListener( 'mousedown' , function (event) {
    clickOutside(outsideElements);
});
//

// set crosBrowser transform style
function setTransformStyle ( element = {}, value = '' ) {
    try {
        element.style.webkitTransform = value;
        element.style.mozTransform = value;
        element.style.msTransform = value;
        element.style.oTransform = value;
        element.style.transform = value;
        return true;
    } catch (err) {
        console.error(err);
        return false;
    }
}
//

// set window on center
function setWindowOnCenter( element = {} ) {
    setTransformStyle(element, 'translate(-50%, -50%)');
    element.style.top = '50%';
    element.style.left = '50%';

    let elementPositions = element.getBoundingClientRect(),
        taskBarHeight = document.getElementById("taskbar-overlay").offsetHeight,
        borderWidthSingle = parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--border-width') ) / 2
    ;
    element.style.top = 
        ( elementPositions.top < borderWidthSingle + taskBarHeight ) ?
            borderWidthSingle + 'px'
                :
            elementPositions.top - taskBarHeight + 'px'
    ;
    element.style.left = 
        ( window.innerWidth - element.offsetWidth > elementPositions.left ) ?
            elementPositions.left + 'px'
                :
            borderWidthSingle + 'px' 
    ;
    
    setTransformStyle(element, 'unset');
}
//

// animation scale 0 to 1
function transformAnimation (
    {
        element        = undefined,
        transition     = '1.00s',
        transitionEnd  = '',
        transformFrom  = 'scale(0)',
        transformTo    = 'scale(1)',
        transformEnd   = '',
        classToRemove  = '',
        classToAdd     = '',
        ...rest
    }
) {
    try {
        if (!element) throw new TypeError("U didn't pass the element");
        unexpectedParams(rest);

        
        setTransformStyle(element, transformFrom);
        blockClicked(element, parseFloat(transition) * 1000 + 1);
        
        setTimeout(() => {
            element.style.transition = transition;
            setTransformStyle(element, transformTo);
        }, 1);
        setTimeout(() => {
            if ( transitionEnd ) element.style.transition = transitionEnd;
            if ( classToRemove ) element.classList.remove(classToRemove);
            if ( transformEnd ) setTransformStyle(element, transformEnd);
            if ( classToAdd ) element.classList.add(classToAdd)
        }, parseFloat(transition) * 1000 + 1 );
    } catch (err) {
        console.error(err);
    }
}
//

// input element before #taskbar
function spawnHtml ( [elementHTML = '', selector = '', positionTop = 0, positionLeft = 0] ) {
    let taskbar = document.getElementById('taskbar-wrap')
        element = false;

    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    
    if ( selector !== '' && document.querySelectorAll(selector)[0] ) {
        element = document.querySelectorAll(selector)[0];
        ( positionTop !== 0 ) ? element.style.top = positionTop + 'px' : false;
        ( positionLeft !== 0 ) ? element.style.left = positionLeft + 'px' : false;
    }
    return element;
}
//

// get usable html height (html - taskbar)
function getUsableHeight () {
    return window.innerHeight - document.querySelector("#taskbar-overlay").offsetHeight;
}
//
// debounce function
function debounce(func, timeout = 300){
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => { func.apply(this, args); }, timeout);
  };
}
//

// helpers END

// removing window, showing menu item, show/hide menu on close button
function closeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        menuElement = document.querySelectorAll(`.task-list-item.hidden[task-id="${taskId}"]`)[0],
        menuWrap = document.getElementById("menu-wrap")
    ;
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)'
    });
    transformAnimation({
        element: elementInTaskBar,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'mg0imp'
    });
        setTasksMargin();
        menuElement.style.margin = '';
        menuElement.style.transform = 'scale(1)'; 
        menuElement.style.height = '';
        menuElement.style.transition = '0s';

    if ( menuWrap.querySelectorAll(".task-list-item.hidden").length == menuWrap.querySelectorAll(".task-list-item").length ) {
        menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');
        document.getElementById("taskbar").style.right = '';
    } else {
        menuWrap.style.transition = '0s';
                
        setTimeout(() => {
            menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');

        }, 1 );
    }

    menuElement.classList.remove("hidden");
    initializeMenu();

    setTimeout(() => {
        windowElement.remove();
        elementInTaskBar.remove();
        setTasksMargin();
        if ( !document.querySelectorAll(".taskbar-item")[0] ) {
            document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 1;
        }

    }, parseFloat(transition) * 1000 );
}
//

// nidding window, set inactive menu item
function hideWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        windowRect = windowElement.getBoundingClientRect()
    ;

    windowElement.setAttribute('prev-top', windowElement.style.top);
    windowElement.setAttribute('prev-left', windowElement.style.left);
    windowElement.style.transition = '1s';
    windowElement.style.top = taskBarElementRect.top + 'px';
    windowElement.style.left = taskBarElementRect.left - windowRect.width/2 + 'px';

    setTimeout(() => {
        elementInTaskBar.classList.remove('active');
    }, parseFloat(transition) * 1000);

    // console.log(elementInTaskBar.getBoundingClientRect());

    // .getBoundingClientRect()
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'hidden'
    });
}
//

// setting window to full screen mode
function maximizeAction(elementHanger, event) {
    let window = elementHanger.closest(".window-green");
    console.log(window);
    console.log(event.target);
    if ( !window.classList.contains("maximized") ) {
        maximizeWindow({currentWindow: window});
    } else {
        minimizeWindow({
            width       : window.getAttribute('minimized-width'),
            height      : window.getAttribute('minimized-height'),
            left        : window.getAttribute('minimized-left'),
            top         : window.getAttribute('minimized-top'),
            right       : window.getAttribute('minimized-right'),
            bottom      : window.getAttribute('minimized-bottom'),
            bodyPaddingRight: 0,
            bodyMargin: 0,
            currentWindow: window,
            showBorders: true,
        });
    }

}

function maximizeWindow({
    currentWindow = {},
    ...rest
}) {
    unexpectedParams(rest);let bordersWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width')),
        bordersWrap = currentWindow.querySelector(".window-borders"),
        bodyElement = currentWindow.querySelector(".window-body"),
        bodyDifference = 0,
        innerPadding = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--inner-padding')),
        headerHeight = parseInt(currentWindow.querySelector(".window-top").offsetHeight),
        width  = parseInt(window.innerWidth),
        height = getUsableHeight(),
        left   = -bordersWidth,
        top    = -bordersWidth;
    width     += bordersWidth * 2;
    height    += bordersWidth + 2;
    bodyDifference =  -(bordersWidth*2);
    bordersWrap.style.opacity = 0;

    currentWindow.classList.add("borders-hidden");
    currentWindow.classList.add("maximized");

    currentWindow.setAttribute('minimized-width', parseFloat(currentWindow.offsetWidth));
    currentWindow.setAttribute('minimized-height', parseFloat(currentWindow.offsetHeight));
    currentWindow.setAttribute('minimized-left', parseFloat(currentWindow.style.left));
    currentWindow.setAttribute('minimized-top', parseFloat(currentWindow.style.top));
    if (currentWindow.style.right) currentWindow.setAttribute('minimized-right', parseFloat(currentWindow.style.right));
    if (currentWindow.style.bottom) currentWindow.setAttribute('minimized-bottom', parseFloat(currentWindow.style.bottom));

    currentWindow.style.left   = left + 'px';
    currentWindow.style.top    = top + 'px';
    currentWindow.style.width  = width  + 'px';
    currentWindow.style.height = height + 'px';
    bodyElement.style.width    = width - bordersWidth - innerPadding * 2 + 'px';
    bodyElement.style.height   = height - bordersWidth - headerHeight - innerPadding * 2 + 'px';
    bodyElement.style.paddingBottom = innerPadding + parseInt(document.querySelector("#taskbar-overlay").offsetHeight) + 'px';
    bodyElement.style.margin   = bodyMargin + 'px';
    bodyElement.style.paddingRight = bodyPaddingRight + 'px';

    
    // console.log(currentWindow.querySelector(".window-top"));
    // console.log(height);
    // console.log(getUsableHeight());
    console.log('maximized');
    
}

function minimizeWindow({
    width       = 0,
    height      = 0,
    left        = 0,
    top         = 0,
    right       = 0,
    bottom      = 0,
    bodyPaddingRight = 0,
    bodyMargin = 0,
    currentWindow = {},
    useBorders  = false,
    showBorders = false,
    ...rest
}) {
    unexpectedParams(rest);
    let bordersWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width')),
        bordersWrap = currentWindow.querySelector(".window-borders"),
        bodyElement = currentWindow.querySelector(".window-body"),
        bodyDifference = 0,
        innerPadding = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--inner-padding')),
        headerHeight = parseInt(currentWindow.querySelector(".window-top").offsetHeight);
    if ( width === 0 )  width  = 250;
    if ( height === 0 ) height = 250;
    if ( currentWindow.classList.contains("borders-hidden") && showBorders ) bordersWrap.style.opacity = '';

    currentWindow.classList.remove("maximized");
    currentWindow.classList.add("minimized");

    currentWindow.style.left   = (left && !right ) ? left   + 'px' : '';
    currentWindow.style.top    = (top  && !bottom) ? top    + 'px' : '';
    currentWindow.style.right  = (right)  ? right  + 'px' : '';
    currentWindow.style.bottom = (bottom) ? bottom + 'px' : '';
    currentWindow.style.width  = width  + 'px';
    currentWindow.style.height = height + 'px';
    bodyElement.style.width    = width - bordersWidth - innerPadding * 2 + 'px';
    bodyElement.style.height   = height - bordersWidth - headerHeight - innerPadding * 2 + 'px';
    bodyElement.style.paddingBottom = innerPadding + parseInt(document.querySelector("#taskbar-overlay").offsetHeight) + 'px';
    bodyElement.style.margin   = bodyMargin + 'px';
    bodyElement.style.paddingRight = bodyPaddingRight + 'px';

    
    console.log(currentWindow.querySelector(".window-top"));
    // console.log(height);
    // console.log(getUsableHeight());
    console.log(111);
}
//

// maximizing window, set inactive menu item
function showWindow ( element = {} ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition')
        // taskId = windowElement.getAttribute('task-id'),
        // elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        // taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        // windowRect = windowElement.getBoundingClientRect()
    ;

    windowElement.style.top = windowElement.getAttribute('prev-top');
    windowElement.style.left = windowElement.getAttribute('prev-left');

    setTimeout(() => {
        windowElement.style.transition = '';
    }, parseFloat(transition) * 1000 + 1);

    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(0)',
        transformTo:  'scale(1)',
        classToRemove: 'hidden'
    });
}
//

// showing ghost window for maximizing
let currentZindex = 5;

// remove ghost window for mouseup
function removeGhost( id = 0 ) {
    let selector = `#ghost-window-${id}`,
        ghost = document.querySelector(selector),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        timeout = parseFloat(transition) * 1000 + 1;
    if ( ghost ) {
        ghost.style.transition = transition;
        ghost.style.width = 0;
        ghost.style.height = 0;
        ghost.style.opacity = 0;
        console.log(getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'));
        console.log(timeout);
        ghost.style.left = ghost.getAttribute('mouse-position') + 'px';
        
        setTimeout(() => {
            if (document.querySelector(selector)) document.querySelector(selector).remove();
        }, timeout);
    }
}
//
function clearGhosts() {
    // if (document.querySelector(`#ghost-window-${ghostWindowId}`)) removeGhost(ghostWindowId);
    document.querySelectorAll(".ghost-window").forEach( item => item.remove() );
    ghostWindowId++;
}

let animations = {},
    animationProps = {};

function clearAnimationsObj() {
    for (const key in animations) {
        if (Object.hasOwnProperty.call(animations, key)) {
            const element = animations[key];
            console.log(animations[key]);
            window.cancelAnimationFrame(animations[key]);
        }
    }
    animations = {};
}

function animateByPixel({
    duration = 750, // ms
    HTMLelement = {},
    property = 'width',
    number   = 1
    }) {
    let start = performance.now();

    animations[property] = window.requestAnimationFrame(function animateByPixel(time) {
    // timeFraction от 0 до 1
        let timeFraction = (time - start) / duration,
            obj = animationProps[property];
        if (timeFraction > 1) timeFraction = 1;
        
        obj.timerID = animations[property];
        obj.timeLeft = Math.floor(duration - duration * timeFraction);
        obj.current = Math.round(obj.start + ( obj.end - obj.start ) * timeFraction);
        HTMLelement.style[property] = obj.start + ( obj.end - obj.start ) * timeFraction  + 'px';
        HTMLelement.setAttribute('time-left', obj.timeLeft);

        if (timeFraction < 1) {
            obj.timerID = animations[property] = window.requestAnimationFrame(animateByPixel);
        } else {
            HTMLelement.setAttribute('time-left', '0');
        }
    });
}

function cancelAnimateByPixel() {
    clearAnimationsObj();
    () => callback();
    return;
}

function showGhost({
    id      = 0,
    toEnd   = false,
    instEnd = true,
    params  = {
        width  : { start: 0, end: 0 },
        height : { start: 0, end: 0 },
        top    : { start: 0, end: 0 },
        left   : { start: 0, end: 0 },
        bottom : { start: 0, end: 0 },
        right  : { start: 0, end: 0 },
    },
    ...rest
}) {
    for (const key in params) {
        let value = params[key];
        if (
            key === 'width' ||
            key === 'height' ||
            key === 'top' ||
            key === 'left' ||
            key === 'bottom' ||
            key === 'right'
        ) {
            for (const keyInner in params[key]) {
                if ( keyInner !== 'start' && keyInner !== 'end' ) {
                    unexpectedParams(params[key]);
                }
                if ( !params[key].hasOwnProperty('start') ) {
                    console.error(`'${key}' must have a 'start' property.`);
                    unexpectedParams(params[key]);
                }
            }
        } else {
            unexpectedParams(params);
        }
    }
    unexpectedParams(rest);
    
    if ( document.querySelector(`#ghost-window-${id}`) !== null && !toEnd ) {
        // console.log("toEnd === false; already exist");
        return;
    // when ghost exist and toEnd === true
    } else if ( document.querySelector(`#ghost-window-${id}`) !== null && toEnd ) {
        let ghostWindowElement = document.querySelector('#ghost-window-'+id),
            timeLeftToAnimate = parseInt(ghostWindowElement.getAttribute('time-left'));
        for (const key in params) {
            let value = params[key];
            if ( animationProps[key].end != params[key].end && instEnd === false ) {
                window.cancelAnimationFrame(animations[key]);
                animationProps[key].start = animationProps[key].current;
                animationProps[key].end = params[key].end;
                animationProps[key].current = 0;
                animateByPixel({ HTMLelement: ghostWindowElement, property: key, number: params[key].end });
            } else if ( timeLeftToAnimate > 0 ) {
                animationProps[key].end = params[key].end;
            } else {
                ghostWindowElement.style[key] = params[key].end +'px';
            }
            if ( !params[key].hasOwnProperty('end') ) ghostWindowElement.style[key] = params[key].start+'px';
        }        
        return;
    }
    
    let ghostWindow = `
        <div id="ghost-window-${id}" class="ghost-window"
            style="
                z-index: ${currentZindex - 2};
                left:   ${ (params.hasOwnProperty('left') && !params.hasOwnProperty('right') ) ? params.left.start : '' }px;
                top:    ${ (params.hasOwnProperty('top')  && !params.hasOwnProperty('bottom')) ? params.top.start  : '' }px;
                right:  ${ (params.hasOwnProperty('right') ) ? params.right.start  + 'px' : '' };
                bottom: ${ (params.hasOwnProperty('bottom')) ? params.bottom.start + 'px' : '' };
                width:  ${ (params.hasOwnProperty('width') ) ? params.width.start  + 'px' : '' };
                height: ${ (params.hasOwnProperty('height')) ? params.height.start + 'px' : '' };
            "
            mouse-position-start="${ (params.hasOwnProperty('left') && !params.hasOwnProperty('right') ) ? params.left.start : params.right.start}">
        </div>`
    ;
    document.querySelector("body").insertAdjacentHTML('beforeEnd', ghostWindow);
    
    let ghostWindowElement = document.querySelector('#ghost-window-'+id);

    if ( toEnd ) {
        animationProps = params;        
        for (const key in params) {
            if ( parseInt(params[key].end) >= 0 ) animateByPixel({ HTMLelement: ghostWindowElement, property: key, number: params[key].end });
        }

        // console.log(animationProps);
        ghostWindowElement.classList.add('first-move');
            
    }
}

// moving window by drug heading,
let ghostWindowId = 0; // global variable for index of ghost windows
function windowsDraging ( windowHead = {} ) {
    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
    let currentWindow = windowHead.closest(".window-green");
    windowHead.onmousedown = function(event) {
        focusWindow(event.target.closest(".window-green"));
        let mouseDownEvent = event,
            coords = getCoords(currentWindow),
            shiftX = event.pageX - coords.left,
            shiftY = event.pageY - coords.top,
            ghostMargin = parseInt( getComputedStyle(document.documentElement).getPropertyValue('--ghost-window-margin') ),
            usableWidth = window.innerWidth,
            usableHeight = getUsableHeight(),
            ghostWidth = usableWidth - ghostMargin*2,
            ghostHeight = usableHeight- ghostMargin*2,
            ghostHalfWidth = Math.round(ghostWidth / 2 - ghostMargin),
            ghostHalfHeight = Math.round(ghostHeight / 2 - ghostMargin),
            posHalfBottom = Math.round(usableHeight - ghostHeight / 2 - ghostMargin),
            posHalfLeft = Math.round(usableWidth - ghostWidth / 2 - ghostMargin),
            needModal = false,
            taskbarOverlay = document.querySelector("#taskbar-overlay"),
            maximizeTop = 150,
            maximizeBottom = 150

        ;
        function moveAt(event) {
            currentWindow.style.left = event.pageX - shiftX + 'px';
            currentWindow.style.top = event.pageY - shiftY + 'px';
        }
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        document.querySelector("html").style.userSelect = 'none';
        
        document.onmousemove = function(event) {
            taskbarOverlay.style.zIndex = '9999';
            moveAt(event);
            // when mouse moves outside usable area
            if ( event.pageY < 0 ){ // top
                windowHead.onmouseup();
                currentWindow.style.top = '0px';
                outsideAlert('Do it', ghostWindowId);
            } else if ( event.pageY > innerHeight ){ // bottom when not full screen mode
                console.log(usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 +
                document.querySelector(".window-head").offsetHeight + 5);
                currentWindow.style.top = 
                usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 -
                document.querySelector(".window-head").offsetHeight + 5 + 'px';
                windowHead.onmouseup();
                outsideAlert('Mouse outside document', ghostWindowId);
            } else if ( event.target == taskbarOverlay ) { // bottom when inside browser but hovered at taskbar
                taskbarOverlay.style.cursor = 'pointer';
                taskbarOverlay.onmouseup = function(event) {
                    console.log(usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 +
                    document.querySelector(".window-head").offsetHeight + 5);
                    currentWindow.style.top = 
                    usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 -
                    document.querySelector(".window-head").offsetHeight + 5 + 'px';
                    windowHead.onmouseup();
                }
            }
            // show ghost window when mouse close to outside
            if ( parseInt(currentWindow.style.top) <= 0 ) { // top border
                if ( event.pageX < maximizeTop ) { // left
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: event.pageY, end: 0 },
                            left   : { start: event.pageX, end: 0 },
                        }
                    });
                } else if ( usableWidth - event.pageX < maximizeTop ) { // right
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: 0, end: 0 },
                            left   : { start: event.pageX, end: usableWidth-ghostWidth/2-ghostMargin },
                        }
                    });
                } else { // middle
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostWidth },
                            height : { start: 0, end: ghostHeight },
                            top    : { start: 0, end: 0 },
                            left   : { start: event.pageX, end: 0 },
                        }
                    });
                }
            } else if ( event.pageX < 5 ) { // left border
                let left = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageX : 0,
                    topBottom = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY: usableHeight - ghostHeight/2-ghostMargin,
                    top = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY : 0;
                if ( event.pageY < maximizeTop ) { // top
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: event.pageY, end: 0 },
                            left   : { start: event.pageX, end: 0 },
                        }
                    });
                } else if ( usableHeight - event.pageY < maximizeTop ) { // bottom
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: event.pageY, end: posHalfBottom },
                            left   : { start: event.pageX, end: 0 },
                        }
                    });
                } else { // middle
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHeight },
                            top    : { start: event.pageY, end: 0 },
                            left   : { start: 0, end: 0 },
                        }
                    });
                }
            } else if ( event.pageX + 5 > usableWidth ) { // right border
                let topBottom = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY: usableHeight - ghostHeight/2-ghostMargin,
                    top = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY : 0,
                    left = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageX : usableWidth - ghostWidth/2-ghostMargin;
                if ( event.pageY < maximizeTop ) { // top
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: event.pageY, end: 0 },
                            left   : { start: event.pageX, end: posHalfLeft },
                        }
                    });
                } else if ( usableHeight - event.pageY < maximizeTop ) { // bottom
                    // showGhost({
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHalfHeight },
                            top    : { start: event.pageY, end: posHalfBottom },
                            left   : { start: event.pageX, end: posHalfLeft },
                        }
                    });
                } else { // middle
                    showGhost({
                        id    : ghostWindowId,
                        toEnd : true,
                        instEnd: false,
                        params: {
                            width  : { start: 0, end: ghostHalfWidth },
                            height : { start: 0, end: ghostHeight },
                            top    : { start: event.pageY, end: 0 },
                            left   : { start: event.pageX, end: posHalfLeft },
                        }
                    });
                }
            } else {
                clearGhosts();
            }
        }
        windowHead.onmouseup = function() {
            if (parseInt(currentWindow.style.top) < 0) currentWindow.style.top = '0px';
            clearGhosts();
            document.onmousemove = null;
            document.querySelector("html").style.userSelect = '';
            currentWindow.onmouseup = null;
            taskbarOverlay.onmouseup = null;
            taskbarOverlay.style.zIndex = '';
            if ( taskbarOverlay.style.cursor == 'pointer' ) taskbarOverlay.style.cursor = '';
            cancelAnimateByPixel();
        }
    }
    windowHead.ondragstart = function() {
        console.log(1);
    }
}
//

// hadler for all borders to resize
const borders = {
    ".window-border-top": {
        selector: ".window-border-top",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: true,
        isPositive: true
    },
    ".window-border-top-right" : {
        selector: ".window-border-top-right",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: true,
        isPositive: true
    },
    ".window-border-right": {
        selector: ".window-border-right",
        borderX: true,
        borderY: false,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-bottom": {
        selector: ".window-border-bottom",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-bottom-left": {
        selector: ".window-border-bottom-left",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-left": {
        selector: ".window-border-left",
        borderX: true,
        borderY: false,
        moveX: true,
        moveY: false,
        isPositive: true
    },
    ".window-border-top-left": {
        selector: ".window-border-top-left",
        borderX: true,
        borderY: true,
        moveX: true,
        moveY: true,
        isPositive: true
    },
    ".window-border-bottom-right": {
        selector: ".window-border-bottom-right",
        borderX: true,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    }
};

document.onmousedown = function(event) {
    Object.keys(borders).forEach(function(selector) {
        if (
            event.target !== document.querySelector(selector)
        ) {
            return false;
        }
    // item.element.onmousedown = function(event) {
        let item = borders[selector],
            mouseDownEvent = event,
            currentWindow = event.target.closest(".window-green"),
            bordersWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width')),
            taskbarOverlay = document.querySelector("#taskbar-overlay"),
            ghostMargin = parseInt( getComputedStyle(document.documentElement).getPropertyValue('--ghost-window-margin') ),
            usableWidth = window.innerWidth,
            usableHeight = getUsableHeight(),
            defaultGhostW = usableWidth - ghostMargin*2,
            defaultGhostH = usableHeight - ghostMargin*2,
            clickposStartLeft = event.x,
            clickposStartTop = event.y,
            windowWidth = currentWindow.offsetWidth,
            windowHeight = currentWindow.offsetHeight,
            bordersElement = currentWindow.querySelector(".window-borders"),
            windowBodyElement = currentWindow.querySelector(".window-body"),
            coords = getCoords(currentWindow),
            shiftX = event.pageX - coords.left,
            shiftY = event.pageY - coords.top,
            windowBodyHeight = windowBodyElement.clientHeight - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding')),
            windowBodyWidth = windowBodyElement.offsetWidth - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding')),
            taskBarHeigth = taskbarOverlay.offsetHeight,
            counter = 300
        ;
        document.querySelector("html").style.userSelect = 'none'; 
        taskbarOverlay.style.zIndex = '9999';

        function getCoords(elem) {
            let box = elem.getBoundingClientRect();
            return {
                top: box.top + pageYOffset,
                left: box.left + pageXOffset
            };
        }

        function moveAt( event, moveX, moveY ) {
            if (moveX) currentWindow.style.left = event.pageX - shiftX + 'px';
            if (moveY) currentWindow.style.top = event.pageY - shiftY + 'px';
        }

        function changeSize( event, item ) {
            let borderX    = item.borderX,
                borderY    = item.borderY,
                isPositive = item.isPositive,
                diffX      = clickposStartLeft - event.pageX,
                diffY      = clickposStartTop - event.pageY;
            function changeWidth( innerWidth = usableWidth, outerWidth = usableWidth - (windowWidth - windowBodyWidth) ) {
                currentWindow.style.width = innerWidth + 'px';
                bordersElement.style.width = innerWidth + 'px';
                windowBodyElement.style.width = outerWidth + 'px';
            }
            function changeHeight( innerHeight = usableHeight, outerHeight = usableHeight - (windowHeight - windowBodyHeight) ) {
                currentWindow.style.height = innerHeight + 'px';
                bordersElement.style.height = innerHeight + 'px';
                windowBodyElement.style.height = outerHeight + 'px';
            }
            bordersElement.style.transition = '0s';
            windowBodyElement.style.transition = '0s';
            
            if ( borderX && isPositive ) {
                if ( windowWidth + diffX > usableWidth ) {
                    changeWidth();
                } else if ( windowWidth + diffX < 250 ) {
                    changeWidth(250, 178);
                } else {
                    currentWindow.style.width = windowWidth + diffX + 'px';
                    bordersElement.style.width = windowWidth + diffX + 'px';
                    windowBodyElement.style.width = windowBodyWidth + diffX + 'px';
                }
            } else if ( borderX && !isPositive ) {
                if ( windowWidth - diffX > usableWidth ) {
                    changeWidth();
                } else if ( windowWidth - diffX < 250 ) {
                    changeWidth(250, 178);
                } else {
                    currentWindow.style.width = windowWidth - diffX + 'px';
                    bordersElement.style.width = windowWidth - diffX + 'px';
                    windowBodyElement.style.width = windowBodyWidth - diffX + 'px';
                }
            }

            if ( borderY && isPositive ) {
                if ( windowHeight + diffY > usableHeight ) {
                    changeHeight();
                } else if ( windowHeight + diffY < 250 ) {
                    changeHeight(250, 160);
                } else {
                    currentWindow.style.height = windowHeight + diffY + 'px';
                    bordersElement.style.height = windowHeight + diffY + 'px';
                    windowBodyElement.style.height = windowBodyHeight + diffY + 'px';
                }
            } else if ( borderY && !isPositive ) {
                if ( windowHeight - diffY > usableHeight ) {
                    changeHeight();
                } else if ( windowHeight - diffY < 250 ) {
                    changeHeight(250, 160);
                } else {
                    currentWindow.style.height = windowHeight - diffY + 'px';
                    bordersElement.style.height = windowHeight - diffY + 'px';
                    windowBodyElement.style.height = windowBodyHeight - diffY + 'px';
                }
            }
            if ( item.selector == '.window-border-left' && windowWidth + diffX >= usableWidth
                || item.selector == '.window-border-top' && windowHeight + diffY >= usableHeight
                || item.selector == '.window-border-top-left' && windowWidth + diffX >= usableWidth && windowHeight + diffY >= usableHeight
                || item.selector == '.window-border-left' && windowWidth + diffX <= 250
                || item.selector == '.window-border-top' && windowHeight + diffY <= 250
                || item.selector == '.window-border-top-left' && windowWidth + diffX <= 250 && windowHeight + diffY <= 250
                ) {
                return;
            } else if ( item.selector == '.window-border-top-left' && windowWidth + diffX >= usableWidth
                        || item.selector == '.window-border-top-left' && windowWidth + diffX <= 250 ) {
                moveAt(event, false, item.moveY);
            } else if ( item.selector == '.window-border-top-left' && windowHeight + diffY >= usableHeight
                        || item.selector == '.window-border-top-left' && windowHeight + diffY <= 250 ) {
                moveAt(event, item.moveX, false);
            } else {
                moveAt(event, item.moveX, item.moveY);
            }
        }

        focusWindow(event.target.closest(".window-green"));
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        // console.log();
        // console.log();
        document.onmousemove = function(event) {
            let clickedClass = mouseDownEvent.target.classList[0],
                windowTop = parseInt(currentWindow.style.top),
                windowLeft = parseInt(currentWindow.style.left),
                pxsToTaskBar = usableHeight - windowTop - currentWindow.offsetHeight,
                windowWidth = currentWindow.offsetWidth;
            document.querySelector("html").style.cursor = getComputedStyle(mouseDownEvent.target).getPropertyValue('cursor');
            if ( event.pageY < 0 ) {
                currentWindow.style.height = parseInt(currentWindow.style.height) + windowTop + 'px';
                bordersElement.style.height = parseInt(bordersElement.style.height) + windowTop + 'px';
                windowBodyElement.style.height = parseInt(windowBodyElement.style.height) + windowTop + 'px';
                document.onmouseup();
                currentWindow.style.top = '0px';
                document.querySelector("html").style.userSelect = '';
                outsideAlert('Do more', ghostWindowId);
            } else {
                changeSize(event, item);
            }

            // console.log(document.querySelectorAll(".ghost-window"));

            if ( windowTop <= 0 && clickedClass === 'window-border-top-left' ) {
                // top left corner
                console.log('top left corner');
                console.log(usableWidth - windowLeft);
                let rightStart = usableWidth - windowLeft - windowWidth - 2;
                if ( windowLeft + windowWidth >= usableWidth ) windowWidth = usableWidth - windowLeft - ghostMargin;
                showGhost({
                    id    : ghostWindowId,
                    toEnd : true,
                    params: {
                        width  : { start: 0, end: windowWidth },
                        height : { start: 0, end: defaultGhostH },
                        top    : { start: ghostMargin },
                        left  : {
                            start: windowLeft - 2
                        },
                    }
                });
            } else if ( windowTop <= 0 && clickedClass === 'window-border-top' ||
                        windowTop <= 0 && clickedClass === 'window-border-top-right' 
            ) { // top border
                console.log('top border');
                let end = windowLeft - 2;
                if ( end < 0 ) end = ghostMargin;
                showGhost({
                    id    : ghostWindowId,
                    toEnd : true,
                    params: {
                        width  : { start: 0, end: windowWidth },
                        height : { start: 0, end: defaultGhostH },
                        top    : { start: event.pageY, end: ghostMargin },
                        left   : { start: event.pageX, end: end },
                    }
                });
            } else if ( pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom' ||
                        pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom-left'
            ) { // bottom border
                console.log('bottom border');
                let end = windowLeft - 2;
                if ( end < 0 ) end = ghostMargin;
                showGhost({
                    id    : ghostWindowId,
                    toEnd : true,
                    params: {
                        width  : { start: 0, end: windowWidth },
                        height : { start: 0, end: defaultGhostH },
                        top    : { start: event.pageY, end: ghostMargin },
                        left   : { start: event.pageX, end: end },
                    }
                });
            } else if ( pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom-right' ) {
                // bottom right corner
                console.log('bottom right corner');
                let rightStart = usableWidth - windowLeft - windowWidth - 2;
                if ( windowLeft < 0 ) windowWidth += windowLeft - ghostMargin;
                showGhost({
                    id    : ghostWindowId,
                    toEnd : true,
                    params: {
                        width  : { start: 0, end: windowWidth },
                        height : { start: 0, end: defaultGhostH },
                        bottom : { start: taskBarHeigth },
                        right  : {
                            // // here is second way of this animations, just use both params
                            // start: usableWidth - event.pageX,
                            // end:   usableWidth - parseInt(currentWindow.style.left) - currentWindow.offsetWidth - bordersWidth - 2
                            start:   rightStart
                        },
                    }
                });
            } else if (
                windowLeft < 1 && clickedClass === 'window-border-left' ||
                windowLeft + windowWidth + 3 > usableWidth && clickedClass === 'window-border-right'
            ) {
                let leftOrRight = ( windowLeft < 1 && clickedClass === 'window-border-left' ) ? 'left': 'right';
                showGhost({
                    id    : ghostWindowId,
                    toEnd : true,
                    params: {
                        width  : { start: 0, end: windowWidth - ghostMargin },
                        height : { start: 0, end:   defaultGhostH },
                        top    : { start: event.pageY, end:   ghostMargin },
                        [leftOrRight] : { start: ghostMargin }, // minimizing by use string in prop
                    }
                });
            } else  {
                clearGhosts();
            }

            // console.log(parseInt(currentWindow.style.left));
            // console.log(currentWindow.offsetWidth);
            // console.log(usableWidth);



        }
        document.onmouseup = function() {
            console.log(1111111111);
            if ( document.getElementById("style-to-all") ) document.getElementById("style-to-all").remove();
            document.onmousemove = null;
            document.onmouseup = null;
            firstTarget = '';
            console.log(currentWindow.style.top);
            if ( parseInt(currentWindow.style.top) < 0 ) currentWindow.style.top = '0px';
            clearGhosts();
            setTimeout(() => {
                bordersElement.style.transition = '';
                windowBodyElement.style.transition = '';
            }, 10);
            document.querySelector("html").style.cursor = '';
            taskbarOverlay.style.zIndex = '';
            cancelAnimateByPixel();
            return false;
        }
    });

    document.ondragstart = function() {
        return false;
    }
}

function outsideAlert( message = 'Your mouse outside document, switch to fullscren mode?', id = 1,  ) {
    if ( !window.screenTop && !window.screenY ) {
        setTimeout(() => {
            // removeGhostWindow(ghostWindowId);
            clearGhosts();
            if ( !window.screenTop && !window.screenY && confirm(message) ) document.documentElement.requestFullscreen();
        }, 10);
    }
}


//

// main menu opening
function toggleMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    if ( menuWrap.classList.contains("active") ) {
        menuWrap.classList.remove("active");
        menuWrap.style.left = '30px';
        document.getElementById("button-toggle").style.top = '0';
    } else {
        menuWrap.classList.add("active");
        menuWrap.style.left = '21px';
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
    // blockClicked( menuWrap, 750);
};
// hang menu opening
forEachClick({
    selector: "#open-tasks",
    func: toggleMainMenu,
    needTimeOut: true,
    secTimeOut: parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--default-transition') ) * 1000,
    selectorToBlocked: "#menu-wrap"
    });
//

// main menu closing
function closeMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    
    menuWrap.classList.remove("active");
    menuWrap.style.left = '30px';
    document.getElementById("button-toggle").style.top = '0';
};

setOutsideClick ('#menu-wrap', '#menu-wrap', closeMainMenu);

//

// set margins inside taskbar
function setTasksMargin ( elementToRemove = {} ) {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = [...taskbarItems].reduce( (prev, current) => prev + current.offsetWidth, 0 ) ,
        taskbarInnerWidth = document.getElementById("taskbar-inner").clientWidth,
        itemsMargin = (taskbarInnerWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount )
    ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    let reduce = [...taskbarItems].reduce( (left, current) => {
        current.style.left = `${left}px`;
        return left + current.offsetWidth + itemsMargin*2;
    
    }, itemsMargin );
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 3}px`;
}
//

// window focus in
function focusInWindow ( element = {}) {
    if ( element.classList.contains("active") ) return;
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
}
//

// window focus out
function focusOutWindow ( activeElement = {} ) {
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = '' ) {
    let element = document.querySelector(`.taskbar-item[task-id="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = '' || {} ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element = {} , event ) {
    let activeElement = document.querySelector(".window-green.active");

    if (activeElement) focusOutWindow(activeElement);
    deactivate('.taskbar-item.active');
    if ( event ) {
        if ( event.target.classList.contains('window-hide') ||
             event.target.classList.contains('hide-1') ||
             event.target.classList.contains('hide-2') ||
             event.target.classList.contains('window-close') ||
             event.target.classList.contains('close-line1') ||
             event.target.classList.contains('close-line2')
            ) {
            return;

        }
    }
    if ( element.classList.contains("active") ) {
        return false;
    }
    activateTaskInTaskbar(element.getAttribute('task-id'));
    focusInWindow(element);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element = {} ) {
    let window = document.querySelector(`.window-green[task-id="${element.getAttribute('task-id')}"]`);

    if ( element.classList.contains("active") && window.classList.contains("active") ) {
        return false;
    }
    
    if ( window.classList.contains("hidden") ) showWindow(window);
    focusWindow(window);
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// jsonWindowItemsData.tasks[0].windowData = `
//             <div class="taskbar-item" task-name="Taskk" task-id="1" style="margin: 0px 139.5px;">
//                 <div class="tpi-title">[ Taskk ]</div>
//             </div>`;

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = {} ) {
    let menuElement = document.getElementById("task-list");
    if (jsonMenuItems) {
        jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
        });
    } else {
        console.error('jsonMenuItems.tasks is empty');
    }
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    
forEachClick( {selector: ".task-list-item",func: callWindow} );
}
//

function removeMenuItem ( element = {}, menu = {} ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight - 2,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';
    // menu.style.bottom = -3 - parseInt(document.getElementById("task-list").offsetHeight) + 'px';

    function animation1() {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2() {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3() {
        return new Promise(resolve => {
            element.classList.add('hidden');
            if ( menu.getElementsByTagName('ul')[0].getElementsByTagName('li').length == menu.getElementsByTagName('ul')[0].querySelectorAll(".hidden").length ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
                setTimeout(() => {
                    menu.style.marginLeft = menuML;
                }, 0);
                setTimeout(() => {
                    menu.style.bottom = '-500px';
                    document.getElementById("taskbar").style.right = (window.innerWidth - document.getElementById('taskbar').offsetWidth) / 2 + 'px';
                    document.getElementById("taskbar").style.transition = '1s';
                }, 10);
                    console.log(menuML);
            }
            
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element = {} ) {
    let taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap'),
        windowData = jsonWindowItemsData.tasks[taskId-1], // like response
        functionsToInit = windowData.functionsToInit,
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        widowActive = document.querySelector(".window-green.active")
    ;
    console.log(windowData);
    
        removeMenuItem(element, menuBox);
        
        let newWindow = spawnHtml( prepareWindow(windowData) );
        setWindowOnCenter(newWindow);
        
        if (functionsToInit) functionsToInit.forEach(function(functionToInit) {
            functionsToInitWindow[functionToInit]();
        });

        spawnTask(windowData);
        deactivate('.taskbar-item.active');
        activateTaskInTaskbar(taskId);

        if (widowActive) widowActive.classList.remove("active");
        newWindow.classList.add("active");
            
        forEachClick( {selector: ".window-green.unhanged",func: focusWindow} );
        // forEachFunc(".window-green.unhanged", windowResize);
        forEachClick( {selector: ".window-close.unhanged",func: closeWindow} );
        forEachClick( {selector: ".window-hide.unhanged",func: hideWindow} );
        forEachClick( {selector: ".window-maximize.unhanged",func: maximizeAction} );
        document.querySelector(".window-close.unhanged").classList.remove("unhanged");
        document.querySelector(".window-hide.unhanged").classList.remove("unhanged");
        document.querySelector(".window-maximize.unhanged").classList.remove("unhanged");
        forEachFunc(".window-head.unhanged", windowsDraging);
        document.querySelector(".window-head.unhanged").classList.remove("unhanged");
        newWindow.getElementsByClassName("window-borders")[0].style.width = newWindow.offsetWidth + 'px';
        newWindow.getElementsByClassName("window-borders")[0].style.height = newWindow.offsetHeight + 'px';
        
        transformAnimation({
            element: newWindow,
            transition: transition,
            transitionEnd: 'none',
            transformFrom: 'scale(0)',
            transformTo:  'scale(1)',
            classToRemove: 'unhanged',
            transformEnd: 'unset',
            // test: '12142'
        });

        if ( document.querySelectorAll(".taskbar-item").length < 2 ) {
            setTimeout(() => {
                setTasksMargin();
            }, 5);
        } else {
            setTasksMargin();
        }

}
//

// spawning window
function prepareWindow ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowId = taskName.toLowerCase().replace( ' ', '-'),
        windowSizeClass = windowObj.windowSizeClass,
        windowBodyStyles = windowObj.windowBodyStyles,
        individualStyles = windowObj.individualStyles,
        stylesHTML = '<style></style>'
        windowData = windowObj.windowData,
        selector = ".window-green.unhanged",
        classHTML = "window-green unhanged"
    ;
    
    if (individualStyles) individualStyles.forEach(function(element) {
        stylesHTML = stylesHTML.replaceAll( '</', `#${windowId} ${element} </` );
    });
    let windowHTML = `
            <div id="${windowId}" class="${classHTML}" task-name="${taskName}" task-id="${taskId}" style="z-index: ${currentZindex++};">
                <div class="window-main">
                    <div class="window-top">
                        <div class="window-hide unhanged">
                            <div class="hide-line"></div>
                        </div>
                        <div class="window-maximize unhanged">
                            <div class="maximize-1"></div>
                            <div class="maximize-2"></div>
                        </div>
                        <div class="window-close unhanged">
                            <div class="close-line1"></div>
                            <div class="close-line2"></div>
                        </div>
                        <div class="window-line"></div>
                    </div>
                    <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                    <div class="window-body ${windowSizeClass}" style="${windowBodyStyles}">
                        ${stylesHTML}
                        ${windowData}
                    </div>
                </div>
                <div class="window-borders">
                    <div class="window-border-top">
                        <div class="window-border-top-right"></div>
                    </div>
                    <div class="window-border-bottom">
                        <div class="window-border-bottom-left"></div>
                    </div>
                    <div class="window-border-left"></div>
                    <div class="window-border-right"></div>
                    <div class="window-border-top-left"></div>
                    <div class="window-border-bottom-right"></div>
                </div>
            </div>
        `;
    return [windowHTML, selector];
}
//

// spawning task in taskbar
function spawnTask ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item unhanged" style="left:-250px" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    if ( !document.querySelectorAll(".taskbar-item.unhanged")[0] ) {
        document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 0;
    }
        document.getElementById('taskbar-inner').insertAdjacentHTML('afterBegin', elementHTML);
    let newTask = document.querySelectorAll(".taskbar-item.unhanged")[0] ;
        forEachClick( {selector: ".taskbar-item.unhanged",func: focusWindowFromTB} );
        newTask.classList.remove("unhanged");

    return newTask;
    
}
//




// functions to render page
// forEachClick( {selector: ".window-close",func: closeWindow} );

// hang window focus handler on window
// forEachClick( {selector: ".window-green",func: focusWindow} );
//

// // hang window focus handler on taskbar item
// forEachClick( {selector: ".taskbar-item",func: focusWindowFromTB} );
// //

// spawnRadar(radarToDecard(spawnRadarVals(5)));

spawnMenuItems(jsonMenuItemsData);

// setTasksMargin();
//










setTimeout(() => {
    document.querySelectorAll(".task-list-item")[0].click();
}, 250);

// setTimeout(() => {
//     document.querySelectorAll(".task-list-item")[0].click();
// }, 820);


</script>
<script>
    // inputting code in highlighted window
    // document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
    
function initHighlitedText( number = 5 ) {
    
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    hljs.highlightAll();
}
functionsToInitWindow['initHighlitedText'] = initHighlitedText;
//
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>

</body>
</html>