<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
    <div id="triger">Click here</div>
    <div class="window-green" task-name="Task">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ Task ]</div></div>
            <div class="window-body">
                <div class="window-content">

                <article class="markdown-body entry-content container-lg" itemprop="text"><h1>Дроны</h1>
                    <p>
                        Мйарп склонился над монитором подключенным к древнему радару.
                        Он ждал появления свидрушей с минуты на минуту. Дроны были наготове, единственная проблема была в том,
                        что для поимки свидруша дрону нужны были X/Y координаты сектора относительно базы с координатами 0/0 в декартовой системе координат.
                        Соответственно координаты квадрата, который располагался на карте  справа от базы были 1/0, снизу 0/-1 и т.д.
                    </p>
                    <p>
                        Если бы обычный радар не вышел из строя, Мйарп бы так не переживал.
                        Но древний радар использовал странную систему координат. Каждый квадрат обозначался уникальным числом. База находилась в квадрате 0.
                        Центр карты на радаре выглядел так:
                    </p>
                    <div class="snippet-clipboard-content position-relative overflow-auto" style="text-align: center;">
                        <pre>
                            <code>
    35  15  16  18  20
    34  14  1   4   21
    33  12  0   6   22
    32  10  9   8   24
    30  28  27  26  25
                            </code>
                        </pre>
                    </div>
                    <p>
                        Дело оставалось за малым - перевести координаты, выдаваемые древним радаром, в координаты понятные дрону.
                        Компьютер понимал любой язык, но Мйарп выбрал свой любимый и набрал
                        <code>define ancientToModern(n int) (x,y int)</code>. Свидрушы приближались...
                    </p>
                </article>
                <br>
                <form id="matrix-form" action="#">
                    <label for="matrix-size">Ширина радара: <input id="matrix_size" name="matrix_size" type="number" step="2" min="5" value="5" max="11"></label>
                    <br>
                    <button type="submit">Создать радар</button>
                </form>

                </div>
            </div>
        </div>
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    <div class="window-green window-radar active" task-name="RADAR">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ RADAR ]</div></div>
            <div class="window-body">
                <div class="window-content">
                    <table>
                        <tbody id="matrix-graph"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    
    <div class="window-green window-radar" task-name="Solution">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ Solution ]</div></div>
            <div class="window-body">
                <div class="window-content">
                    <pre><code id="code-wrap" class="hljs language-javascript"></code></pre>
                    <br>
                    <div class="author">Styled with <a href="https://highlightjs.org/">highlightjs.org</a></div>
                </div>
            </div>
        </div>
        
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div class="taskbar-item-empty">
                This is a taskbar, open menu and start your first task...
            </div>


            <div class="taskbar-item active" task-name="Task">
                <div class="tpi-title">[ Task ]</div>
            </div>

            <div class="taskbar-item" task-name="Solution">
                <div class="tpi-title">[ Solution ]</div>
            </div>

            <div class="taskbar-item" task-name="RADAR">
                <div class="tpi-title">[ RADAR ]</div>
            </div>








        </div>
        <div id="taskbar-overlay"></div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
//

// render matrix on submit button in task window
let form = document.getElementById("matrix-form");
form.onsubmit = function () {
    let number = document.getElementById("matrix_size").value;
    spawnRadar( radarToDecard( spawnRadarVals(number) ) );
    document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
    return false;
};
//

// function blocker clicks on active animation
function blockClicked ( element = {}, time = 0 ) {
    element.classList.add("blocked");
    let blockedTimeOut = setTimeout(() => {
        element.classList.remove("blocked");
    }, time);
}
//

// checking object for emptiness
function isEmptyObject ( rest = {} ) {
    return ( Object.keys(rest).length === 0 && rest.constructor === Object ) ?  true :  true;
}
//

// checking unexpected params in function, if have throw error
function unexpectedParams(rest) {
    if ( !isEmptyObject(rest) ) throw new TypeError( message = 'Unexpected params given:' + JSON.stringify(rest) );
}
//

// hang any function onClick by selector
function forEachClick (
    {
        selector          = '',
        func              = Function,
        needTimeOut       = false,
        secTimeOut        = 0,
        selectorToBlocked = '',
        ...rest
    }
) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("Ur pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or u pass not a Function");
        if ( typeof needTimeOut !== 'boolean' ) throw new TypeError("U pass not Boolean in 'needTimeOut'");
        if ( typeof secTimeOut !== 'number' ) throw new TypeError("U pass not Number in 'secTimeOut'");
        if ( secTimeOut < 0 ) throw new TypeError("Ur Number - 'secTimeOut' is lower then 0");
        if ( needTimeOut !== false && typeof selectorToBlocked !== 'string' ||
             needTimeOut !== false && selectorToBlocked === '' ||
             needTimeOut !== false && !document.querySelectorAll(selectorToBlocked)[0]
            ) throw new ReferenceError("Ur pass not String in 'selectorToBlocked' or it wasn't found");
        unexpectedParams(rest);

        [].forEach.call( document.querySelectorAll(selector), function(element) {
            element.onclick = function(event) {
                if ( element.classList.contains("blocked") || element.closest(".blocked") === null ) {
                    func(this);
                    if ( needTimeOut ) {
                        blockClicked(document.querySelectorAll(selectorToBlocked)[0], secTimeOut);
                    }
                }
            }
        });
    } catch (err) {
        console.error(err);
    }
}
//

// hang any function by selector
function forEachFunc ( selector = '', func = Function ) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("Ur pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or it's not a Function");

        document.querySelectorAll(selector).forEach( function(element) {
            func(element);
        });
    } catch (err) {
        console.error(err);
    }
}
//

// array with selectors and functions when click outside it, hanged on document event click
let outsideElements = [];

function setOutsideClick ( selector = '', parent = '', funCall = Function ) {
    try {
        if ( typeof selector !== 'string' ) throw new TypeError("U pass not String in 'selector'");
        if ( typeof parent !== 'string' ) throw new TypeError("U pass not String in 'parent'");
        if (!document.querySelectorAll(selector)[0]) throw new ReferenceError("Ur 'selector' wasn't found");
        if (!document.querySelectorAll(parent)[0]) throw new ReferenceError("Ur 'parent' wasn't found");
        if ( funCall == Function || typeof funCall !== 'function') throw new TypeError("U didn't pass the 'funCall', or u pass not a Function");

        outsideElements.push({
            selector: selector,
            parent: parent,
            funCall: funCall
        });
        
    } catch (err) {
        console.error(err);
    }
}

function clickOutside ( outsideElements = [] ) {
    outsideElements.forEach( function(element) {
        if ( document.querySelectorAll(element.selector)[0].classList.contains("active") && !event.target.closest(element.parent) ) {
            element.funCall();
            console.warn('click outside element in array');
        }
    });
}

document.addEventListener( 'click' , function (event) {
    clickOutside(outsideElements);
});
//

// set crosBrowser transform style
function setTransformStyle ( element = {}, value = '' ) {
    try {
        element.style.webkitTransform = value;
        element.style.mozTransform = value;
        element.style.msTransform = value;
        element.style.oTransform = value;
        element.style.transform = value;
        return true;
    } catch (err) {
        console.error(err);
        return false;
    }
}
//

// set window on center
function setWindowOnCenter( element = {} ) {
    setTransformStyle(element, 'translate(-50%, -50%)');
    element.style.top = '50%';
    element.style.left = '50%';

    let elementPositions = element.getBoundingClientRect(),
        taskBarHeight = document.getElementById("taskbar-overlay").offsetHeight,
        borderWidthSingle = parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--border-width') ) / 2
    ;
    element.style.top = 
        ( elementPositions.top < borderWidthSingle + taskBarHeight ) ?
            borderWidthSingle + 'px'
                :
            elementPositions.top - taskBarHeight + 'px'
    ;
    element.style.left = 
        ( window.innerWidth - element.offsetWidth > elementPositions.left ) ?
            elementPositions.left + 'px'
                :
            borderWidthSingle + 'px' 
    ;
    
    setTransformStyle(element, 'unset');
}
//

// animation scale 0 to 1
function transformAnimation (
    {
        element        = undefined,
        transition     = '1.00s',
        transformFrom  = 'scale(0)',
        transformTo    = 'scale(1)',
        transformEnd = '',
        classToRemove  = '',
        ...rest
    }
) {
    try {
        if (!element) throw new TypeError("U didn't pass the element");
        unexpectedParams(rest);

        
        setTransformStyle(element, transformFrom);
        blockClicked(element, parseFloat(transition) * 1000 + 1);
        
        setTimeout(() => {
            element.style.transition = transition;
            setTransformStyle(element, transformTo);
        }, 1);
        setTimeout(() => {
            if ( classToRemove ) element.classList.remove(classToRemove);
            if ( transformEnd ) setTransformStyle(element, transformEnd);
        }, parseFloat(transition) * 1000 + 1 );
    } catch (err) {
        console.error(err);
    }
}
//

// input element before #taskbar
function spawnHtml ( elementHTML = '', positionTop = 0, positionLeft = 0 ) {
    let taskbar = document.getElementById('taskbar-wrap');
    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    ( positionTop !== 0 ) ? elementHTML.style.top = positionTop + 'px' : false;
    ( positionLeft !== 0 ) ? elementHTML.style.left = positionLeft + 'px' : false;
}
//

// closing window on close button
// function closeWindow ( element = Element ) {
//     element.onclick = async function(event) {
//         let windowGreen = event.target.closest(".window-green"),
//             windowTop = event.target.closest(".window-top"),
//             windowHead = event.target.closest(".window-green").querySelector(".window-head"),
//             windowBody = event.target.closest(".window-green").querySelector(".window-body"),
//             windowHeader = event.target.closest(".window-green").querySelector(".wh-header")
//         ;
        
//         await animateWindow(windowGreen, "hide-background");
//         await animateWindow(windowBody, "hide-height");
//               animateWindow(windowGreen, "", 0, 25);
//         await animateWindow(windowTop, "hide-width");
//         await animateWindow(windowTop, "hide-padding");
//         await animateWindow(windowTop, "hide-height");
//         await animateWindow(windowBody, "hide-margin");
//               animateWindow(windowBody, "hide-height");
//               windowHead.style.position = "relative";
//               animateWindow(windowHead, "hide-margin");
        
//               animateWindow(windowGreen, "", windowHeader.offsetWidth + 10, 0);
//               animateWindow(windowHead, "", windowHeader.offsetWidth + 10, 0);

//         console.log(windowHeader.offsetWidth);
//     }
// }
//

// moving window by drug heading
let currentZindex = 5;
function windowsDraging ( windowHead = {} ) {
    let currentWindow = windowHead.closest(".window-green");

    windowHead.onmousedown = function(e) {
        focusWindow(e.target.closest(".window-green"));
        let coords = getCoords(currentWindow),
            shiftX = e.pageX - coords.left,
            shiftY = e.pageY - coords.top
        ;
        currentWindow.style.position = 'absolute';
        moveAt(e);
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        
        function moveAt(e) {
            currentWindow.style.left = e.pageX - shiftX + 'px';
            currentWindow.style.top = e.pageY - shiftY + 'px';
            console.log(e.pageX);
            console.log(e.pageY);
        }
        document.onmousemove = function(e) {
            moveAt(e);
        };
        windowHead.onmouseup = function() {
            document.onmousemove = null;
            currentWindow.onmouseup = null;
        };

    }

    windowHead.ondragstart = function() {
        return false;
    };

    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
}
// hang draging function on elements
forEachFunc(".window-head", windowsDraging);
//

// main menu opening
function toggleMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    if ( menuWrap.classList.contains("active") ) {
        menuWrap.classList.remove("active");
        menuWrap.style.left = '30px';
        document.getElementById("button-toggle").style.top = '0';
    } else {
        menuWrap.classList.add("active");
        menuWrap.style.left = '21px';
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
    // blockClicked( menuWrap, 750);
};
// hang menu opening
forEachClick({
    selector: "#open-tasks",
    func: toggleMainMenu,
    needTimeOut: true,
    secTimeOut: parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--default-transition') ) * 1000,
    selectorToBlocked: "#menu-wrap"
    });
//

// main menu closing
function closeMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    
    menuWrap.classList.remove("active");
    menuWrap.style.left = '30px';
    document.getElementById("button-toggle").style.top = '0';
};

setOutsideClick ('#menu-wrap', '#menu-wrap', closeMainMenu);

//

// set margins inside taskbar
function setTasksMargin () {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = 0;
        taskbar = document.getElementById("taskbar"),
        itemsMargin = 0
    ;
    taskbar.style.overflow = 'hidden';
    taskbarItems.forEach( function (element) { 
        taskbarItemsWidth = taskbarItemsWidth + element.clientWidth;
    });

    itemsMargin = (taskbar.clientWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount ) - 1.5 ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    taskbarItems.forEach( function (element) { 
        element.style.margin = `0 ${itemsMargin}px`;
    });
    setTimeout(() => {
        taskbar.style.overflow = 'unset';
        taskbar.style.overflowY = 'hidden';
    }, 750);
    
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 3}px`;
}
//

// window focus in
function focusInWindow ( element = {}, borderWidth = 0) {
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
    element.style.top = parseInt(element.style.top) - borderWidth + 'px';
    element.style.left = parseInt(element.style.left) - borderWidth + 'px';
}
//

// window focus out
function focusOutWindow ( activeElement = {}, borderWidth = 0 ) {

    activeElement.style.top = parseInt(activeElement.style.top) + borderWidth + 'px';
    activeElement.style.left = parseInt(activeElement.style.left) + borderWidth + 'px';
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = '' ) {
    let element = document.querySelector(`.taskbar-item[task-name="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = '' || {} ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        } else {
            console.error('U dont have active elemnt to deactivate!');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element = {} ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    let activeElement = document.querySelector(".window-green.active"),
        borderWidth = parseInt(window.getComputedStyle(activeElement, null).getPropertyValue('border-width'))
    ;

    focusOutWindow(activeElement, borderWidth );
    deactivate('.taskbar-item.active');
    activateTaskInTaskbar(element.getAttribute('task-name'));
    focusInWindow(element, borderWidth);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element = {} ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    focusWindow(document.querySelector(`.window-green[task-name="${element.getAttribute('task-name')}"]`));
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// jsonWindowItemsData.tasks[0].windowData = `
//             <div class="taskbar-item" task-name="Taskk" task-id="1" style="margin: 0px 139.5px;">
//                 <div class="tpi-title">[ Taskk ]</div>
//             </div>`;

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = {} ) {
    let menuElement = document.getElementById("task-list");
    jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
    });
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    
forEachClick( {selector: ".task-list-item",func: callWindow} );
}
//

function removeMenuItem ( element = {}, menu = {} ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';

    function animation1() {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2() {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3() {
        return new Promise(resolve => {
            element.remove();
            if (! menu.getElementsByTagName('ul')[0].getElementsByTagName('div')[0] ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
            setTimeout(() => {
                menu.style.marginLeft = menuML;
            }, 0);
            setTimeout(() => {
                menu.style.marginLeft = 0;
                menu.style.width = 0;
                menu.style.border = 0;
                menu.style.padding = 0;
                menu.style.overflow = 'hidden';

                document.getElementById("taskbar").style.right = (window.innerWidth - document.getElementById('taskbar').offsetWidth) / 2 + 'px';
                document.getElementById("taskbar").style.transition = '1s';
            }, 10);
                console.log(menuML);
            }
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element = {} ) {
    let taskName = element.getAttribute('task-name'),
        taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap'),
        windowData = jsonWindowItemsData.tasks[taskId-1], // like response
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition')    
    ;
    
        removeMenuItem(element, menuBox);
        
        spawnHtml( spawnWindow(windowData) );
        let newWindow = spawnTask(windowData);
        
        setWindowOnCenter(newWindow);        

        document.querySelector(".window-green.active").classList.remove("active");
        newWindow.classList.add("active");
        
            
        forEachClick( {selector: ".window-green.unhanged",func: focusWindow} );

        // forEachClick( {selector: ".window-close.unhanged",func: closeWindow} );

        forEachFunc(".window-head.unhanged", windowsDraging);

        newWindow.getElementsByClassName("window-borders")[0].style.width = newWindow.offsetWidth + 'px';
        newWindow.getElementsByClassName("window-borders")[0].style.height = newWindow.offsetHeight + 'px';
        
        transformAnimation({
            element: newWindow,
            transition: transition,
            transformFrom: 'scale(0)',
            transformTo:  'scale(1)',
            classToRemove: 'unhanged',
            // test: '12142'
        });

        setTasksMargin();
}
//

// spawning window
function spawnWindow ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowSizeClass = windowObj.windowSizeClass,
        windowData = windowObj.windowData;
    let windowHTML = `
            <div class="window-green unhanged" task-name="${taskName}" task-id="${taskId}" style="z-index: ${currentZindex++};">
                <div class="window-main">
                    <div class="window-top">
                        <div class="window-minimize">
                            <div class="minimize-1"></div>
                            <div class="minimize-2"></div>
                        </div>
                        <div class="window-close unhanged">
                            <div class="close-line1"></div>
                            <div class="close-line2"></div>
                        </div>
                        <div class="window-line"></div>
                    </div>
                    <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                    <div class="window-body ${windowSizeClass}">
                        ${windowData}
                    </div>
                </div>
                <div class="window-borders">
                    <div class="window-border-top">
                        <div class="window-border-top-right"></div>
                    </div>
                    <div class="window-border-bottom">
                        <div class="window-border-bottom-left"></div>
                    </div>
                    <div class="window-border-left"></div>
                    <div class="window-border-right"></div>
                    <div class="window-border-top-left"></div>
                    <div class="window-border-bottom-right"></div>
                </div>
            </div>
        `;
    return windowHTML;
}
//


// spawning task in taskbar
function spawnTask ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    
        document.getElementById('taskbar').insertAdjacentHTML('beforeend', elementHTML);

    return document.querySelectorAll(".window-green.unhanged")[0];
    
}
//





// minimizing window on close button
function minimizeWindow ( element = {} ) {
    
}
//








// functions to render page
// forEachClick( {selector: ".window-close",func: closeWindow} );

// hang window focus handler on window
forEachClick( {selector: ".window-green",func: focusWindow} );
//

// hang window focus handler on taskbar item
forEachClick( {selector: ".taskbar-item",func: focusWindowFromTB} );
//

spawnRadar(radarToDecard(spawnRadarVals(5)));

spawnMenuItems(jsonMenuItemsData);

setTasksMargin();
//













</script>
<script>
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>