<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
   

<!-- 
    <div class="par-block" style="
    background: red;
    top: 0px;
    left: 0px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: green;
    left: 0px;
    left: 0px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: blue;
    top: 0px;
    left: 500px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: black;
    left: 900px;
    top: 249px;
    border: 1px solid white;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div> -->
    <div id="triger">Click here</div>
    <!-- 
    <div class="window-green" task-name="Task">
        <div class="window-top">
            <div class="window-minimize">
                <div class="minimize-1"></div>
                <div class="minimize-2"></div>
            </div>
            <div class="window-close">
                <div class="close-line1"></div>
                <div class="close-line2"></div>
            </div>
            <div class="window-line"></div>
            <div class="window-head"><div class="wh-header">[  ]</div></div>
        </div>
        <div class="window-body">
            
        </div>
    </div> -->
    <div class="window-green" task-name="Task">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ Task ]</div></div>
            <div class="window-body">
                <div class="window-content">

                <article class="markdown-body entry-content container-lg" itemprop="text"><h1>Дроны</h1>
                    <p>
                        Мйарп склонился над монитором подключенным к древнему радару.
                        Он ждал появления свидрушей с минуты на минуту. Дроны были наготове, единственная проблема была в том,
                        что для поимки свидруша дрону нужны были X/Y координаты сектора относительно базы с координатами 0/0 в декартовой системе координат.
                        Соответственно координаты квадрата, который располагался на карте  справа от базы были 1/0, снизу 0/-1 и т.д.
                    </p>
                    <p>
                        Если бы обычный радар не вышел из строя, Мйарп бы так не переживал.
                        Но древний радар использовал странную систему координат. Каждый квадрат обозначался уникальным числом. База находилась в квадрате 0.
                        Центр карты на радаре выглядел так:
                    </p>
                    <div class="snippet-clipboard-content position-relative overflow-auto" style="text-align: center;">
                        <pre>
                            <code>
    35  15  16  18  20
    34  14  1   4   21
    33  12  0   6   22
    32  10  9   8   24
    30  28  27  26  25
                            </code>
                        </pre>
                    </div>
                    <p>
                        Дело оставалось за малым - перевести координаты, выдаваемые древним радаром, в координаты понятные дрону.
                        Компьютер понимал любой язык, но Мйарп выбрал свой любимый и набрал
                        <code>define ancientToModern(n int) (x,y int)</code>. Свидрушы приближались...
                    </p>
                </article>
                <br>
                <form id="matrix-form" action="#">
                    <label for="matrix-size">Ширина радара: <input id="matrix_size" name="matrix_size" type="number" step="2" min="5" value="5" max="11"></label>
                    <br>
                    <button type="submit">Создать радар</button>
                </form>

                </div>
            </div>
        </div>
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    <div class="window-green window-radar active" task-name="RADAR">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ RADAR ]</div></div>
            <div class="window-body">
                <div class="window-content">
                    <table>
                        <tbody id="matrix-graph"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    
    <div class="window-green window-radar" task-name="Solution">
        <div class="window-main">
            <div class="window-top">
                <div class="window-minimize">
                    <div class="minimize-1"></div>
                    <div class="minimize-2"></div>
                </div>
                <div class="window-close">
                    <div class="close-line1"></div>
                    <div class="close-line2"></div>
                </div>
                <div class="window-line"></div>
            </div>
            <div class="window-head"><div class="wh-header">[ Solution ]</div></div>
            <div class="window-body">
                <div class="window-content">
                    <pre><code id="code-wrap" class="hljs language-javascript"></code></pre>
                    <br>
                    <div class="author">Styled with <a href="https://highlightjs.org/">highlightjs.org</a></div>
                </div>
            </div>
        </div>
        
        <div class="window-borders" style="width: 572px; height: 600px;">
            <div class="window-border-top">
                <div class="window-border-top-right"></div>
            </div>
            <div class="window-border-bottom">
                <div class="window-border-bottom-left"></div>
            </div>
            <div class="window-border-left"></div>
            <div class="window-border-right"></div>
            <div class="window-border-top-left"></div>
            <div class="window-border-bottom-right"></div>
        </div>
    </div>
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div class="taskbar-item-empty">
                This is a taskbar, open menu and start your first task...
            </div>


            <div class="taskbar-item active" task-name="Task">
                <div class="tpi-title">[ Task ]</div>
            </div>

            <div class="taskbar-item" task-name="Solution">
                <div class="tpi-title">[ Solution ]</div>
            </div>

            <div class="taskbar-item" task-name="RADAR">
                <div class="tpi-title">[ RADAR ]</div>
            </div>








        </div>
        <div id="taskbar-overlay"></div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
//

// render matrix on submit button in task window
let form = document.getElementById("matrix-form");
form.onsubmit = function () {
    let number = document.getElementById("matrix_size").value;
    spawnRadar( radarToDecard( spawnRadarVals(number) ) );
    document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
    return false;
};
//

// function animate for closing window
async function animateWindow (element = [] || {}, cssClass = "hide-height", width = false, height = false) {
    element.classList.add("transition");
    isNaN(parseInt(width)) ? width = false : width = parseInt(width);
    isNaN(parseInt(height)) ? height = false : height = parseInt(height);
    let promise = new Promise((resolve, reject) => {
        if ( Array.isArray(element) ) {
            element.forEach( element => {
                element.style.width = element.offsetWidth + 'px';
                element.style.height = element.offsetHeight + 'px';
                setTimeout( () => element.classList.add(cssClass), 5000);
            });
        } else {
            let padding = parseInt(window.getComputedStyle(element, null).getPropertyValue('padding'));
            

            if ( padding === 0 ) {
                element.setAttribute('initial-width', element.offsetWidth + 'px');
                element.setAttribute('initial-height', element.offsetHeight + 'px');
                width ? element.style.width = width + 'px' : element.style.width = element.offsetWidth + 'px';
                height ? element.style.height = height + 'px' : element.style.height = element.offsetHeight + 'px';
            } else {
                element.setAttribute('initial-width', element.offsetWidth - padding*2 + 'px');
                element.setAttribute('initial-height', element.offsetHeight - padding*2 + 'px');
                width ? element.style.width = width + 'px' : element.style.width = element.offsetWidth - padding*2 + 'px';
                height ? element.style.height = height + 'px' : element.style.height = element.offsetHeight - padding*2 + 'px';
            }
            !width && !height ? setTimeout( () => resolve(element.classList.add(cssClass)), 350) : false;
            
        }
    });
    let result = await promise;
}
//

// function blocker clicks on active animation
function blockClicks ( element = Element, time = Number ) {
    element.classList.add("blocked");
    let blockedTimeOut = setTimeout(() => {
        element.classList.remove("blocked");
    }, time);
}
//

// hang any function onClick by selector
function forEachClick (
    args = {
        selector: String,
        func: Function,
        needTimeOut: Boolean,
        secTimeOut: Number,
        selectorToBlocked: String
    }
) {
    [].forEach.call( document.querySelectorAll(args.selector), function(element) {
        element.onclick = function(event) {
            if ( element.classList.contains("blocked") || element.closest(".blocked") === null ) {
                args.func(this);
                if ( args.needTimeOut ) {
                    blockClicks(document.querySelectorAll(args.selectorToBlocked)[0], args.secTimeOut);
                }
            }
        }
    });
}
//

// hang any function by selector
function forEachFunc ( selector = String, func = Function ) {
    document.querySelectorAll(selector).forEach( function(element) {
        func(element);
    });
}
//

// array with selectors and functions when click outside it, hanged on document event click
let outsideElements = [];

function setOutsideClick ( selector = String, parent = String, funCall = Function ) {
    outsideElements.push({
        selector: selector,
        parent: parent,
        funCall: funCall
    });
}

function clickOutside ( outsideElements = Array ) {
    outsideElements.forEach( function(element) {
        if ( document.querySelectorAll(element.selector)[0].classList.contains("active") && !event.target.closest(element.parent) ) {
            element.funCall();
            console.warn('click outside element in array');
        }
    });
}

document.addEventListener( 'click' , function (event) {
    clickOutside(outsideElements);
});
//

// input element before #taskbar
function spawnHtml ( elementHTML = String, positionTop = 0, positionLeft = 0 ) {
    let taskbar = document.getElementById('taskbar-wrap');
    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    ( positionTop !== 0 ) ? elementHTML.style.top = positionTop + 'px' : false;
    ( positionLeft !== 0 ) ? elementHTML.style.left = positionLeft + 'px' : false;
}
//

// closing window on close button
function closeWindow ( element = Element ) {
    element.onclick = async function(event) {
        let windowGreen = event.target.closest(".window-green"),
            windowTop = event.target.closest(".window-top"),
            windowHead = event.target.closest(".window-green").querySelector(".window-head"),
            windowBody = event.target.closest(".window-green").querySelector(".window-body"),
            windowHeader = event.target.closest(".window-green").querySelector(".wh-header")
        ;
        
        await animateWindow(windowGreen, "hide-background");
        await animateWindow(windowBody, "hide-height");
              animateWindow(windowGreen, "", 0, 25);
        await animateWindow(windowTop, "hide-width");
        await animateWindow(windowTop, "hide-padding");
        await animateWindow(windowTop, "hide-height");
        await animateWindow(windowBody, "hide-margin");
              animateWindow(windowBody, "hide-height");
              windowHead.style.position = "relative";
              animateWindow(windowHead, "hide-margin");
        
              animateWindow(windowGreen, "", windowHeader.offsetWidth + 10, 0);
              animateWindow(windowHead, "", windowHeader.offsetWidth + 10, 0);

        console.log(windowHeader.offsetWidth);
    }
}
//

// moving window by drug heading
let currentZindex = 5;
function windowsDraging ( windowHead = Element ) {
    let currentWindow = windowHead.closest(".window-green");

    windowHead.onmousedown = function(e) {
        focusWindow(e.target.closest(".window-green"));
        let coords = getCoords(currentWindow),
            shiftX = e.pageX - coords.left,
            shiftY = e.pageY - coords.top
        ;
        currentWindow.style.position = 'absolute';
        moveAt(e);
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        
        function moveAt(e) {
            currentWindow.style.left = e.pageX - shiftX + 'px';
            currentWindow.style.top = e.pageY - shiftY + 'px';
            console.log(e.pageX);
            console.log(e.pageY);
        }
        document.onmousemove = function(e) {
            moveAt(e);
        };
        windowHead.onmouseup = function() {
            document.onmousemove = null;
            currentWindow.onmouseup = null;
        };

    }

    windowHead.ondragstart = function() {
        return false;
    };

    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
}
// hang draging function on elements
forEachFunc(".window-head", windowsDraging);
//

// main menu opening
function toggleMainMenu ( event = Event ) {
    let menuWrap = document.getElementById("menu-wrap");
    if ( menuWrap.classList.contains("active") ) {
        menuWrap.classList.remove("active");
        menuWrap.style.left = '30px';
        document.getElementById("button-toggle").style.top = '0';
    } else {
        menuWrap.classList.add("active");
        menuWrap.style.left = '21px';
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
    // blockClicks( menuWrap, 750);
};
// hang menu opening
forEachClick({
    selector: "#open-tasks",
    func: toggleMainMenu,
    needTimeOut: true,
    secTimeOut: parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--default-transition') ) * 1000,
    selectorToBlocked: "#menu-wrap"
    });
//

// main menu closing
function closeMainMenu ( event = Event ) {
    document.getElementById("menu-wrap").classList.remove("active");
    document.getElementById("button-toggle").style.top = '0';
};

setOutsideClick ('#menu-wrap', '#menu-wrap', closeMainMenu);

//

// set margins inside taskbar
function setTasksMargin () {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = 0;
        taskbar = document.getElementById("taskbar"),
        itemsMargin = 0
    ;
    taskbar.style.overflow = 'hidden';
    taskbarItems.forEach( function (element) { 
        taskbarItemsWidth = taskbarItemsWidth + element.clientWidth;
    });

    itemsMargin = (taskbar.clientWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount ) - 1.5 ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    taskbarItems.forEach( function (element) { 
        element.style.margin = `0 ${itemsMargin}px`;
    });
    setTimeout(() => {
        taskbar.style.overflow = 'unset';
        taskbar.style.overflowY = 'hidden';
    }, 750);
    
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 3}px`;
}
//

// window focus in
function focusInWindow ( element = Element, borderWidth = Number) {
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
    element.style.top = parseInt(element.style.top) - borderWidth + 'px';
    element.style.left = parseInt(element.style.left) - borderWidth + 'px';
}
//

// window focus out
function focusOutWindow ( activeElement = Element, borderWidth = Number ) {

    activeElement.style.top = parseInt(activeElement.style.top) + borderWidth + 'px';
    activeElement.style.left = parseInt(activeElement.style.left) + borderWidth + 'px';
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = String ) {
    let element = document.querySelector(`.taskbar-item[task-name="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = String || Element ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        } else {
            console.error('U dont have active elemnt to deactivate!');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element = Element ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    let activeElement = document.querySelector(".window-green.active"),
        borderWidth = parseInt(window.getComputedStyle(activeElement, null).getPropertyValue('border-width'))
    ;

    focusOutWindow(activeElement, borderWidth );
    deactivate('.taskbar-item.active');
    activateTaskInTaskbar(element.getAttribute('task-name'));
    focusInWindow(element, borderWidth);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element = Element ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    focusWindow(document.querySelector(`.window-green[task-name="${element.getAttribute('task-name')}"]`));
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// jsonWindowItemsData.tasks[0].windowData = `
//             <div class="taskbar-item" task-name="Taskk" task-id="1" style="margin: 0px 139.5px;">
//                 <div class="tpi-title">[ Taskk ]</div>
//             </div>`;

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = Object ) {
    let menuElement = document.getElementById("task-list");
    jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
    });
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    
forEachClick( {selector: ".task-list-item",func: callWindow} );
}
//

function removeMenuItem ( element = Element, menu = Element ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';

    function animation1(x) {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1.35s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2(x) {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3(x) {
        return new Promise(resolve => {
            element.remove();
            if (! menu.getElementsByTagName('ul')[0].getElementsByTagName('div')[0] ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
            setTimeout(() => {
                menu.style.marginLeft = menuML;
            }, 0);
            setTimeout(() => {
                menu.style.marginLeft = 0;
                menu.style.width = 0;
                menu.style.border = 0;
                menu.style.padding = 0;
                menu.style.overflow = 'hidden';

                document.getElementById("taskbar").style.right = (window.innerWidth - document.getElementById('taskbar').offsetWidth) / 2 + 'px';
                document.getElementById("taskbar").style.transition = '1s';
            }, 10);
                console.log(menuML);
            }
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element = Element ) {
    let taskName = element.getAttribute('task-name'),
        taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap'),
        windowData = jsonWindowItemsData.tasks[taskId-1], // like response
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition')    
    ;
    
        removeMenuItem(element, menuBox);
        
        spawnHtml( spawnWindow(windowData) );
        let newWindow = spawnTask(windowData);
        
        setWindowOnCenter(newWindow);

        document.querySelector(".window-green.active").classList.remove("active");
        newWindow.classList.add("active");
        
            
        forEachClick( {selector: ".window-green.unhanged",func: focusWindow} );
        forEachClick( {selector: ".window-close.unhanged",func: closeWindow} );
        forEachFunc(".window-head.unhanged", windowsDraging);

        newWindow.classList.remove('unhanged');
        document.querySelectorAll(".window-head.unhanged")[0].classList.remove('unhanged');
            newWindow.getElementsByClassName("window-borders")[0].style.width = newWindow.offsetWidth + 'px';
            newWindow.getElementsByClassName("window-borders")[0].style.height = newWindow.offsetHeight + 'px';

        setTimeout(() => {
            newWindow.style.transition = transition;
            newWindow.style.webkitTransform = 'scale(1)';
            newWindow.style.mozTransform = 'scale(1)';
            newWindow.style.msTransform = 'scale(1)';
            newWindow.style.oTransform = 'scale(1)';
            newWindow.style.transform = 'scale(1)';
        }, 1);

        setTimeout(() => {
            newWindow.style.transition = 'unset';
        }, parseFloat(transition) * 1000 + 1 );

        
        setTasksMargin();
        // console.log(taskName);
        // console.log(taskId);
        // console.log(windowData);
}
//

// spawning window
function spawnWindow ( windowObj = Object ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowSizeClass = windowObj.windowSizeClass,
        windowData = windowObj.windowData;
    let windowHTML = `
            <div class="window-green unhanged" task-name="${taskName}" task-id="${taskId}"
                style="z-index: ${currentZindex++};
                left: 50%;
                top: 50%;
                -webkit-transform: translate(-50%, -50%);
                -moz-transform: translate(-50%, -50%);
                -ms-transform: translate(-50%, -50%);
                -o-transform: translate(-50%, -50%);
                transform: translate(-50%, -50%);
            ">
                <div class="window-main">
                    <div class="window-top">
                        <div class="window-minimize">
                            <div class="minimize-1"></div>
                            <div class="minimize-2"></div>
                        </div>
                        <div class="window-close unhanged">
                            <div class="close-line1"></div>
                            <div class="close-line2"></div>
                        </div>
                        <div class="window-line"></div>
                    </div>
                    <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                    <div class="window-body ${windowSizeClass}">
                        ${windowData}
                    </div>
                </div>
                <div class="window-borders">
                    <div class="window-border-top">
                        <div class="window-border-top-right"></div>
                    </div>
                    <div class="window-border-bottom">
                        <div class="window-border-bottom-left"></div>
                    </div>
                    <div class="window-border-left"></div>
                    <div class="window-border-right"></div>
                    <div class="window-border-top-left"></div>
                    <div class="window-border-bottom-right"></div>
                </div>
            </div>
        `;
    return windowHTML;
}
//


// spawning task in taskbar
function spawnTask ( windowObj = Object ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    
        document.getElementById('taskbar').insertAdjacentHTML('beforeend', elementHTML);

    return document.querySelectorAll(".window-green.unhanged")[0];
    
}
//

// set window on center
function setWindowOnCenter( element = Element ) {
    console.log( document.getElementById("taskbar-overlay").offsetHeight );
    console.log( element.getBoundingClientRect() );
    let elementPositions = element.getBoundingClientRect(),
        taskBarHeight = document.getElementById("taskbar-overlay").offsetHeight,
        borderWidthSingle = parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--border-width') ) / 2
    ;
    element.style.top = 
        ( elementPositions.top < borderWidthSingle + taskBarHeight ) ?
            borderWidthSingle + 'px'
                :
            elementPositions.top - taskBarHeight + 'px'
    ;
    element.style.left = 
        ( window.innerWidth - element.offsetWidth > elementPositions.left ) ?
            elementPositions.left + 'px'
                :
            borderWidthSingle + 'px' 
    ;

    element.style.webkitTransform = 'scale(0)';
    element.style.mozTransform = 'scale(0)';
    element.style.msTransform = 'scale(0)';
    element.style.oTransform = 'scale(0)';
    element.style.transform = 'scale(0)';
    


}
//











// functions to render page
forEachClick( {selector: ".window-close",func: closeWindow} );

// hang window focus handler on window
forEachClick( {selector: ".window-green",func: focusWindow} );
//

// hang window focus handler on taskbar item
forEachClick( {selector: ".taskbar-item",func: focusWindowFromTB} );
//

spawnRadar(radarToDecard(spawnRadarVals(5)));

spawnMenuItems(jsonMenuItemsData);

setTasksMargin();
//













</script>
<script>
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>