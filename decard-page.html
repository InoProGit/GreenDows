<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
    <div id="triger">Click here</div>
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div id="taskbar-inner">
                <div class="taskbar-item-empty">
                    This is a taskbar, open menu and start your task...
                </div>
            </div>
        </div>
        <div id="taskbar-overlay"></div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// object with functions to init window interface
let functionsToInitWindow = {};
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
function initRadar( number = 5 ) {
    spawnRadar(radarToDecard(spawnRadarVals(number)));
}
functionsToInitWindow['initRadar'] = initRadar;
//

// render matrix on submit button in task window
function initFormMatrixSubmit() {
    let form = document.getElementById("matrix-form");
    form.onsubmit = function () {
        let number = document.getElementById("matrix_size").value;
        spawnRadar( radarToDecard( spawnRadarVals(number) ) );
        document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
        return false;
    };
}

functionsToInitWindow['initFormMatrixSubmit'] = initFormMatrixSubmit;
//

// function blocker clicks on active animation
function blockClicked ( element = {}, time = 0 ) {
    element.classList.add("blocked");
    let blockedTimeOut = setTimeout(() => {
        element.classList.remove("blocked");
    }, time);
}
//

// checking object for emptiness
function isEmptyObject ( rest = {} ) {
    return ( Object.keys(rest).length === 0 && rest.constructor === Object ) ?  true :  true;
}
//

// checking unexpected params in function, if have throw error
function unexpectedParams(rest) {
    if ( !isEmptyObject(rest) ) throw new TypeError( message = 'Unexpected params given:' + JSON.stringify(rest) );
}
//

// hang any function onClick by selector
function forEachClick (
    {
        selector          = '',
        func              = Function,
        needTimeOut       = false,
        secTimeOut        = 0,
        selectorToBlocked = '',
        ...rest
    }
) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or u pass not a Function");
        if ( typeof needTimeOut !== 'boolean' ) throw new TypeError("U pass not Boolean in 'needTimeOut'");
        if ( typeof secTimeOut !== 'number' ) throw new TypeError("U pass not Number in 'secTimeOut'");
        if ( secTimeOut < 0 ) throw new TypeError("Ur Number - 'secTimeOut' is lower then 0");
        if ( needTimeOut !== false && typeof selectorToBlocked !== 'string' ||
             needTimeOut !== false && selectorToBlocked === '' ||
             needTimeOut !== false && !document.querySelectorAll(selectorToBlocked)[0]
            ) throw new ReferenceError("U pass not String in 'selectorToBlocked' or it wasn't found");
        unexpectedParams(rest);

        [].forEach.call( document.querySelectorAll(selector), function(element) {
            element.onclick = function(event) {
                if ( element.classList.contains("blocked") || element.closest(".blocked") === null ) {
                    func(this, event);
                    if ( needTimeOut ) {
                        blockClicked(document.querySelectorAll(selectorToBlocked)[0], secTimeOut);
                    }
                }
            }
        });
    } catch (err) {
        console.error(err);
    }
}
//

// hang any function by selector
function forEachFunc ( selector = '', func = Function ) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or it's not a Function");

        document.querySelectorAll(selector).forEach( function(element) {
            func(element);
        });
    } catch (err) {
        console.error(err);
    }
}
//

// array with selectors and functions when click outside it, hanged on document event click
let outsideElements = [];

function setOutsideClick ( selector = '', parent = '', funCall = Function ) {
    try {
        if ( typeof selector !== 'string' ) throw new TypeError("U pass not String in 'selector'");
        if ( typeof parent !== 'string' ) throw new TypeError("U pass not String in 'parent'");
        if (!document.querySelectorAll(selector)[0]) throw new ReferenceError("Ur 'selector' wasn't found");
        if (!document.querySelectorAll(parent)[0]) throw new ReferenceError("Ur 'parent' wasn't found");
        if ( funCall == Function || typeof funCall !== 'function') throw new TypeError("U didn't pass the 'funCall', or u pass not a Function");

        outsideElements.push({
            selector: selector,
            parent: parent,
            funCall: funCall
        });
        
    } catch (err) {
        console.error(err);
    }
}

function clickOutside ( outsideElements = [] ) {
    outsideElements.forEach( function(element) {
        if ( document.querySelectorAll(element.selector)[0].classList.contains("active") && !event.target.closest(element.parent) ) {
            element.funCall();
            console.warn('click outside element in array');
        }
    });
}

document.addEventListener( 'click' , function (event) {
    clickOutside(outsideElements);
});
//

// set crosBrowser transform style
function setTransformStyle ( element = {}, value = '' ) {
    try {
        element.style.webkitTransform = value;
        element.style.mozTransform = value;
        element.style.msTransform = value;
        element.style.oTransform = value;
        element.style.transform = value;
        return true;
    } catch (err) {
        console.error(err);
        return false;
    }
}
//

// set window on center
function setWindowOnCenter( element = {} ) {
    setTransformStyle(element, 'translate(-50%, -50%)');
    element.style.top = '50%';
    element.style.left = '50%';

    let elementPositions = element.getBoundingClientRect(),
        taskBarHeight = document.getElementById("taskbar-overlay").offsetHeight,
        borderWidthSingle = parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--border-width') ) / 2
    ;
    element.style.top = 
        ( elementPositions.top < borderWidthSingle + taskBarHeight ) ?
            borderWidthSingle + 'px'
                :
            elementPositions.top - taskBarHeight + 'px'
    ;
    element.style.left = 
        ( window.innerWidth - element.offsetWidth > elementPositions.left ) ?
            elementPositions.left + 'px'
                :
            borderWidthSingle + 'px' 
    ;
    
    setTransformStyle(element, 'unset');
}
//

// animation scale 0 to 1
function transformAnimation (
    {
        element        = undefined,
        transition     = '1.00s',
        transitionEnd  = '',
        transformFrom  = 'scale(0)',
        transformTo    = 'scale(1)',
        transformEnd   = '',
        classToRemove  = '',
        classToAdd  = '',
        ...rest
    }
) {
    try {
        if (!element) throw new TypeError("U didn't pass the element");
        unexpectedParams(rest);

        
        setTransformStyle(element, transformFrom);
        blockClicked(element, parseFloat(transition) * 1000 + 1);
        
        setTimeout(() => {
            element.style.transition = transition;
            setTransformStyle(element, transformTo);
        }, 1);
        setTimeout(() => {
            if ( transitionEnd ) element.style.transition = transitionEnd;
            if ( classToRemove ) element.classList.remove(classToRemove);
            if ( transformEnd ) setTransformStyle(element, transformEnd);
            if ( classToAdd ) element.classList.add(classToAdd)
        }, parseFloat(transition) * 1000 + 1 );
    } catch (err) {
        console.error(err);
    }
}
//

// input element before #taskbar
function spawnHtml ( [elementHTML = '', selector = '', positionTop = 0, positionLeft = 0] ) {
    let taskbar = document.getElementById('taskbar-wrap')
        element = false;

    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    
    if ( selector !== '' && document.querySelectorAll(selector)[0] ) {
        element = document.querySelectorAll(selector)[0];
        ( positionTop !== 0 ) ? element.style.top = positionTop + 'px' : false;
        ( positionLeft !== 0 ) ? element.style.left = positionLeft + 'px' : false;
    }
    return element;
}
//

// removing window, showing menu item, show/hide menu on close button
function closeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        menuElement = document.querySelectorAll(`.task-list-item.hidden[task-id="${taskId}"]`)[0],
        menuWrap = document.getElementById("menu-wrap")
    ;
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)'
    });
    transformAnimation({
        element: elementInTaskBar,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'mg0imp'
    });
        setTasksMargin();
        menuElement.style.margin = '';
        menuElement.style.transform = 'scale(1)'; 
        menuElement.style.height = '';
        menuElement.style.transition = '0s';

    if ( menuWrap.querySelectorAll(".task-list-item.hidden").length == menuWrap.querySelectorAll(".task-list-item").length ) {
        menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');
        document.getElementById("taskbar").style.right = '';
    } else {
        menuWrap.style.transition = '0s';
                
        setTimeout(() => {
            menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');

        }, 1 );
    }

    menuElement.classList.remove("hidden");
    initializeMenu();

    setTimeout(() => {
        windowElement.remove();
        elementInTaskBar.remove();
        setTasksMargin();
        if ( !document.querySelectorAll(".taskbar-item")[0] ) {
            document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 1;
        }

    }, parseFloat(transition) * 1000 );
}
//

// minimizing window, set inactive menu item
function minimizeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        windowRect = windowElement.getBoundingClientRect()
    ;

    windowElement.setAttribute('prev-top', windowElement.style.top);
    windowElement.setAttribute('prev-left', windowElement.style.left);
    windowElement.style.transition = '1s';
    windowElement.style.top = taskBarElementRect.top + 'px';
    windowElement.style.left = taskBarElementRect.left - windowRect.width/2 + 'px';

    setTimeout(() => {
        elementInTaskBar.classList.remove('active');
    }, parseFloat(transition) * 1000);

    // console.log(elementInTaskBar.getBoundingClientRect());

    // .getBoundingClientRect()
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'minimized'
    });
}
//

// maximizing window, set inactive menu item
function maximizeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition')
        // taskId = windowElement.getAttribute('task-id'),
        // elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        // taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        // windowRect = windowElement.getBoundingClientRect()
    ;


    windowElement.style.top = windowElement.getAttribute('prev-top');
    windowElement.style.left = windowElement.getAttribute('prev-left');

    setTimeout(() => {
        windowElement.style.transition = '';
    }, parseFloat(transition) * 1000 + 1);

    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(0)',
        transformTo:  'scale(1)',
        classToRemove: 'minimized'
    });
}
//

// moving window by drug heading
let currentZindex = 5;
function windowsDraging ( windowHead = {} ) {
    let currentWindow = windowHead.closest(".window-green");

    windowHead.onmousedown = function(e) {
        focusWindow(e.target.closest(".window-green"));
        let coords = getCoords(currentWindow),
            shiftX = e.pageX - coords.left,
            shiftY = e.pageY - coords.top
        ;
        currentWindow.style.position = 'absolute';
        moveAt(e);
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        
        function moveAt(e) {
            currentWindow.style.left = e.pageX - shiftX + 'px';
            currentWindow.style.top = e.pageY - shiftY + 'px';
            // console.log(e.pageX);
            // console.log(e.pageY);
        }
        document.onmousemove = function(e) {
            moveAt(e);
        };
        windowHead.onmouseup = function() {
            document.onmousemove = null;
            currentWindow.onmouseup = null;
        };

    }

    windowHead.ondragstart = function() {
        return false;
    };

    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
}
//

// hadler for all borders to resize
function windowResize ( window = {} ) {
    const borders = [
        {
            element: window.querySelector('.window-border-top'),
            borderX: false,
            borderY: true,
            moveX: false,
            moveY: true,
            isPositive: true
        },
        {
            element: window.querySelector('.window-border-right'),
            borderX: true,
            borderY: false,
            moveX: false,
            moveY: false,
            isPositive: false
        },
        {
            element: window.querySelector('.window-border-bottom'),
            borderX: false,
            borderY: true,
            moveX: false,
            moveY: false,
            isPositive: false
        },
        {
            element: window.querySelector('.window-border-left'),
            borderX: true,
            borderY: false,
            moveX: true,
            moveY: false,
            isPositive: true
        },
        {
            element: window.querySelector('.window-border-top-left'),
            borderX: true,
            borderY: true,
            moveX: true,
            moveY: true,
            isPositive: true
        },
        {
            element: window.querySelector('.window-border-bottom-right'),
            borderX: true,
            borderY: true,
            moveX: false,
            moveY: false,
            isPositive: false
        }
    ];

    borders.forEach(function (item) {
        item.element.onmousedown = function(event) {
            let clickPosLeft = event.x,
                clickPosTop = event.y,
                windowWidth = window.offsetWidth,
                windowHeight = window.offsetHeight,
                bordersElement = window.querySelector('.window-borders'),
                windowBodyElement = window.querySelector('.window-body'),
                coords = getCoords(window),
                shiftX = event.pageX - coords.left,
                shiftY = event.pageY - coords.top,
                windowBodyHeight = windowBodyElement.clientHeight - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding')),
                windowBodyWidth = windowBodyElement.offsetWidth - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding'))
            ;

            function getCoords(elem) {
                let box = elem.getBoundingClientRect();
                return {
                    top: box.top + pageYOffset,
                    left: box.left + pageXOffset
                };
            }

            function moveAt( event, moveX, moveY ) {
                if (moveX) window.style.left = event.pageX - shiftX + 'px';
                if (moveY) window.style.top = event.pageY - shiftY + 'px';
            }

            function changeSize( event, borderX, borderY, isPositive ) {
                let diffX = clickPosLeft - event.pageX,
                    diffY = clickPosTop - event.pageY;
                bordersElement.style.transition = '0s';
                
                if ( borderX && isPositive ) {
                    window.style.width = windowWidth + diffX + 'px';
                    bordersElement.style.width = windowWidth + diffX + 'px';
                    windowBodyElement.style.width = windowBodyWidth + diffX + 'px';
                } else if ( borderX && !isPositive ) {
                    window.style.width = windowWidth - diffX + 'px';
                    bordersElement.style.width = windowWidth - diffX + 'px';
                    windowBodyElement.style.width = windowBodyWidth - diffX + 'px';
                }
                
                if ( borderY && isPositive ) {
                    window.style.height = windowHeight + diffY + 'px';
                    bordersElement.style.height = windowHeight + diffY + 'px';
                    windowBodyElement.style.height = windowBodyHeight + diffY + 'px';
                } else if ( borderY && !isPositive ) {
                    window.style.height = windowHeight - diffY + 'px';
                    bordersElement.style.height = windowHeight - diffY + 'px';
                    windowBodyElement.style.height = windowBodyHeight - diffY + 'px';
                }
            }

            focusWindow(event.target.closest(".window-green"));
            changeSize(event, item.borderX, item.borderY, item.isPositive);
            window.style.zIndex = currentZindex++; // z-index priority

            document.onmousemove = function(event) {
                changeSize(event, item.borderX, item.borderY, item.isPositive);
                moveAt(event, item.moveX, item.moveY);
            };

            window.onmouseup = function() {
                document.onmousemove = null;
                window.onmouseup = null;
                bordersElement.style.transition = '';
            };

        }
        item.element.ondragstart = function() {
            return false;
        };

    });

}
//

// main menu opening
function toggleMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    if ( menuWrap.classList.contains("active") ) {
        menuWrap.classList.remove("active");
        menuWrap.style.left = '30px';
        document.getElementById("button-toggle").style.top = '0';
    } else {
        menuWrap.classList.add("active");
        menuWrap.style.left = '21px';
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
    // blockClicked( menuWrap, 750);
};
// hang menu opening
forEachClick({
    selector: "#open-tasks",
    func: toggleMainMenu,
    needTimeOut: true,
    secTimeOut: parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--default-transition') ) * 1000,
    selectorToBlocked: "#menu-wrap"
    });
//

// main menu closing
function closeMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    
    menuWrap.classList.remove("active");
    menuWrap.style.left = '30px';
    document.getElementById("button-toggle").style.top = '0';
};

setOutsideClick ('#menu-wrap', '#menu-wrap', closeMainMenu);

//

// set margins inside taskbar
function setTasksMargin ( elementToRemove = {} ) {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = [...taskbarItems].reduce( (prev, current) => prev + current.offsetWidth, 0 ) ,
        taskbarInnerWidth = document.getElementById("taskbar-inner").clientWidth,
        itemsMargin = (taskbarInnerWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount )
    ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    let reduce = [...taskbarItems].reduce( (left, current) => {
        current.style.left = `${left}px`;
        return left + current.offsetWidth + itemsMargin*2;
    
    }, itemsMargin );
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 3}px`;
}
//

// window focus in
function focusInWindow ( element = {}) {
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
}
//

// window focus out
function focusOutWindow ( activeElement = {} ) {
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = '' ) {
    let element = document.querySelector(`.taskbar-item[task-id="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = '' || {} ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element = {} , event ) {
    let activeElement = document.querySelector(".window-green.active");

    if (activeElement) focusOutWindow(activeElement);
    deactivate('.taskbar-item.active');
    if ( event ) {
        if ( event.target.classList.contains('window-minimize') ||
             event.target.classList.contains('minimize-1') ||
             event.target.classList.contains('minimize-2') ||
             event.target.classList.contains('window-close') ||
             event.target.classList.contains('close-line1') ||
             event.target.classList.contains('close-line2')
            ) {
            return;

        }
    }
    if ( element.classList.contains("active") ) {
        return false;
    }
    activateTaskInTaskbar(element.getAttribute('task-id'));
    focusInWindow(element);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element = {} ) {
    let window = document.querySelector(`.window-green[task-id="${element.getAttribute('task-id')}"]`);

    if ( element.classList.contains("active") && window.classList.contains("active") ) {
        return false;
    }
    
    if ( window.classList.contains("minimized") ) maximizeWindow(window);
    focusWindow(window);
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// jsonWindowItemsData.tasks[0].windowData = `
//             <div class="taskbar-item" task-name="Taskk" task-id="1" style="margin: 0px 139.5px;">
//                 <div class="tpi-title">[ Taskk ]</div>
//             </div>`;

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = {} ) {
    let menuElement = document.getElementById("task-list");
    if (jsonMenuItems) {
        jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
        });
    } else {
        console.error('jsonMenuItems.tasks is empty');
    }
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    
forEachClick( {selector: ".task-list-item",func: callWindow} );
}
//

function removeMenuItem ( element = {}, menu = {} ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight - 2,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';
    // menu.style.bottom = -3 - parseInt(document.getElementById("task-list").offsetHeight) + 'px';

    function animation1() {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2() {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3() {
        return new Promise(resolve => {
            element.classList.add('hidden');
            if ( menu.getElementsByTagName('ul')[0].getElementsByTagName('li').length == menu.getElementsByTagName('ul')[0].querySelectorAll(".hidden").length ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
                setTimeout(() => {
                    menu.style.marginLeft = menuML;
                }, 0);
                setTimeout(() => {
                    menu.style.bottom = '-500px';
                    document.getElementById("taskbar").style.right = (window.innerWidth - document.getElementById('taskbar').offsetWidth) / 2 + 'px';
                    document.getElementById("taskbar").style.transition = '1s';
                }, 10);
                    console.log(menuML);
            }
            
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element = {} ) {
    let taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap'),
        windowData = jsonWindowItemsData.tasks[taskId-1], // like response
        functionsToInit = windowData.functionsToInit,
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        widowActive = document.querySelector(".window-green.active")
    ;
    console.log(windowData);
    
        removeMenuItem(element, menuBox);
        
        let newWindow = spawnHtml( prepareWindow(windowData) );
        setWindowOnCenter(newWindow);
        
        if (functionsToInit) functionsToInit.forEach(function(functionToInit) {
            functionsToInitWindow[functionToInit]();
        });

        spawnTask(windowData);
        deactivate('.taskbar-item.active');
        activateTaskInTaskbar(taskId);

        if (widowActive) widowActive.classList.remove("active");
        newWindow.classList.add("active");
            
        forEachClick( {selector: ".window-green.unhanged",func: focusWindow} );
        forEachFunc(".window-green.unhanged", windowResize);
        forEachClick( {selector: ".window-close.unhanged",func: closeWindow} );
        forEachClick( {selector: ".window-minimize.unhanged",func: minimizeWindow} );
        document.querySelector(".window-close.unhanged").classList.remove("unhanged");
        document.querySelector(".window-minimize.unhanged").classList.remove("unhanged");
        forEachFunc(".window-head.unhanged", windowsDraging);
        document.querySelector(".window-head.unhanged").classList.remove("unhanged");
        newWindow.getElementsByClassName("window-borders")[0].style.width = newWindow.offsetWidth + 'px';
        newWindow.getElementsByClassName("window-borders")[0].style.height = newWindow.offsetHeight + 'px';
        
        transformAnimation({
            element: newWindow,
            transition: transition,
            transitionEnd: 'none',
            transformFrom: 'scale(0)',
            transformTo:  'scale(1)',
            classToRemove: 'unhanged',
            transformEnd: 'unset',
            // test: '12142'
        });

        if ( document.querySelectorAll(".taskbar-item").length < 2 ) {
            setTimeout(() => {
                setTasksMargin();
            }, 5);
        } else {
            setTasksMargin();
        }

}
//

// spawning window
function prepareWindow ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowId = taskName.toLowerCase().replace( ' ', '-'),
        windowSizeClass = windowObj.windowSizeClass,
        windowBodyStyles = windowObj.windowBodyStyles,
        individualStyles = windowObj.individualStyles,
        stylesHTML = '<style></style>'
        windowData = windowObj.windowData,
        selector = ".window-green.unhanged",
        classHTML = "window-green unhanged"
    ;
    
    if (individualStyles) individualStyles.forEach(function(element) {
        stylesHTML = stylesHTML.replaceAll( '</', `#${windowId} ${element} </` );
    });
    let windowHTML = `
            <div id="${windowId}" class="${classHTML}" task-name="${taskName}" task-id="${taskId}" style="z-index: ${currentZindex++};">
                <div class="window-main">
                    <div class="window-top">
                        <div class="window-minimize unhanged">
                            <div class="minimize-1"></div>
                            <div class="minimize-2"></div>
                        </div>
                        <div class="window-close unhanged">
                            <div class="close-line1"></div>
                            <div class="close-line2"></div>
                        </div>
                        <div class="window-line"></div>
                    </div>
                    <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                    <div class="window-body ${windowSizeClass}" style="${windowBodyStyles}">
                        ${stylesHTML}
                        ${windowData}
                    </div>
                </div>
                <div class="window-borders">
                    <div class="window-border-top">
                        <div class="window-border-top-right"></div>
                    </div>
                    <div class="window-border-bottom">
                        <div class="window-border-bottom-left"></div>
                    </div>
                    <div class="window-border-left"></div>
                    <div class="window-border-right"></div>
                    <div class="window-border-top-left"></div>
                    <div class="window-border-bottom-right"></div>
                </div>
            </div>
        `;
    return [windowHTML, selector];
}
//

// spawning task in taskbar
function spawnTask ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item unhanged" style="left:-250px" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    if ( !document.querySelectorAll(".taskbar-item.unhanged")[0] ) {
        document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 0;
    }
        document.getElementById('taskbar-inner').insertAdjacentHTML('afterBegin', elementHTML);
    let newTask = document.querySelectorAll(".taskbar-item.unhanged")[0] ;
        forEachClick( {selector: ".taskbar-item.unhanged",func: focusWindowFromTB} );
        newTask.classList.remove("unhanged");

    return newTask;
    
}
//




// functions to render page
// forEachClick( {selector: ".window-close",func: closeWindow} );

// hang window focus handler on window
// forEachClick( {selector: ".window-green",func: focusWindow} );
//

// // hang window focus handler on taskbar item
// forEachClick( {selector: ".taskbar-item",func: focusWindowFromTB} );
// //

// spawnRadar(radarToDecard(spawnRadarVals(5)));

spawnMenuItems(jsonMenuItemsData);

// setTasksMargin();
//










setTimeout(() => {
    document.querySelectorAll(".task-list-item")[1].click();
}, 5);

setTimeout(() => {
    document.querySelectorAll(".task-list-item")[0].click();
}, 800);


</script>
<script>
    // inputting code in highlighted window
    // document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
    
function initHighlitedText( number = 5 ) {
    
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    hljs.highlightAll();
}
functionsToInitWindow['initHighlitedText'] = initHighlitedText;
//
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>

</body>
</html>