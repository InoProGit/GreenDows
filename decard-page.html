<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
   

<!-- 
    <div class="par-block" style="
    background: red;
    top: 0px;
    left: 0px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: green;
    left: 0px;
    left: 0px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: blue;
    top: 0px;
    left: 500px;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div>
    <div class="par-block" style="
    background: black;
    left: 900px;
    top: 249px;
    border: 1px solid white;
">
        <div class="top-block"></div>
        <div class="body-block"></div>
    </div> -->
    <div id="triger">Click here</div>
    <!-- 
    <div class="window-green" task-name="Task">
        <div class="window-top">
            <div class="window-minimize">
                <div class="minimize-1"></div>
                <div class="minimize-2"></div>
            </div>
            <div class="window-close">
                <div class="close-line1"></div>
                <div class="close-line2"></div>
            </div>
            <div class="window-line"></div>
            <div class="window-head"><div class="wh-header">[  ]</div></div>
        </div>
        <div class="window-body">
            
        </div>
    </div> -->
    <div class="window-green active" task-name="Task">
        <div class="window-top">
            <div class="window-minimize">
                <div class="minimize-1"></div>
                <div class="minimize-2"></div>
            </div>
            <div class="window-close">
                <div class="close-line1"></div>
                <div class="close-line2"></div>
            </div>
            <div class="window-line"></div>
        </div>
        <div class="window-head"><div class="wh-header">[ Task ]</div></div>
        <div class="window-body">
            <article class="markdown-body entry-content container-lg" itemprop="text"><h1>Дроны</h1>
                <p>
                    Мйарп склонился над монитором подключенным к древнему радару.
                    Он ждал появления свидрушей с минуты на минуту. Дроны были наготове, единственная проблема была в том,
                    что для поимки свидруша дрону нужны были X/Y координаты сектора относительно базы с координатами 0/0 в декартовой системе координат.
                    Соответственно координаты квадрата, который располагался на карте  справа от базы были 1/0, снизу 0/-1 и т.д.
                </p>
                <p>
                    Если бы обычный радар не вышел из строя, Мйарп бы так не переживал.
                    Но древний радар использовал странную систему координат. Каждый квадрат обозначался уникальным числом. База находилась в квадрате 0.
                    Центр карты на радаре выглядел так:
                </p>
                <div class="snippet-clipboard-content position-relative overflow-auto" style="text-align: center;">
                    <pre>
                        <code>
35  15  16  18  20
34  14  1   4   21
33  12  0   6   22
32  10  9   8   24
30  28  27  26  25
                        </code>
                    </pre>
                </div>
                <p>
                    Дело оставалось за малым - перевести координаты, выдаваемые древним радаром, в координаты понятные дрону.
                    Компьютер понимал любой язык, но Мйарп выбрал свой любимый и набрал
                    <code>define ancientToModern(n int) (x,y int)</code>. Свидрушы приближались...
                </p>
            </article>
            <br>
            <form id="matrix-form" action="#">
                <label for="matrix-size">Ширина радара: <input id="matrix_size" name="matrix_size" type="number" step="2" min="5" value="5" max="11"></label>
                <br>
                <button type="submit">Создать радар</button>
            </form>
        </div>
    </div>
    <div class="window-green window-radar" task-name="RADAR">
        <div class="window-top">
            <div class="window-minimize">
                <div class="minimize-1"></div>
                <div class="minimize-2"></div>
            </div>
            <div class="window-close">
                <div class="close-line1"></div>
                <div class="close-line2"></div>
            </div>
            <div class="window-line"></div>
        </div>
        <div class="window-head"><div class="wh-header">[ RADAR ]</div></div>
        <div class="window-body">
            <table>
                <tbody id="matrix-graph"></tbody>
            </table>
        </div>
    </div>
    
    <div class="window-green window-radar" task-name="Solution">
        <div class="window-top">
            <div class="window-minimize">
                <div class="minimize-1"></div>
                <div class="minimize-2"></div>
            </div>
            <div class="window-close">
                <div class="close-line1"></div>
                <div class="close-line2"></div>
            </div>
            <div class="window-line"></div>
        </div>
        <div class="window-head"><div class="wh-header">[ Solution ]</div></div>
        <div class="window-body">
            <pre><code id="code-wrap" class="hljs language-javascript"></code></pre>
            <br>
            <div class="author">Styled with <a href="https://highlightjs.org/">highlightjs.org</a></div>
        </div>
    </div>
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div class="taskbar-item-empty">
                This is a taskbar, open menu and start your first task...
            </div>


            <div class="taskbar-item active" task-name="Task">
                <div class="tpi-title">[ Task ]</div>
            </div>

            <div class="taskbar-item" task-name="Solution">
                <div class="tpi-title">[ Solution ]</div>
            </div>

            <div class="taskbar-item" task-name="RADAR">
                <div class="tpi-title">[ RADAR ]</div>
            </div>








        </div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
//

// render matrix on submit button in task window
let form = document.getElementById("matrix-form");
form.onsubmit = function () {
    let number = document.getElementById("matrix_size").value;
    spawnRadar( radarToDecard( spawnRadarVals(number) ) );
    document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
    return false;
};
//

// function animate for closing window
async function animateWindow (element = [] || {}, cssClass = "hide-height", width = false, height = false) {
    element.classList.add("transition");
    isNaN(parseInt(width)) ? width = false : width = parseInt(width);
    isNaN(parseInt(height)) ? height = false : height = parseInt(height);
    let promise = new Promise((resolve, reject) => {
        if ( Array.isArray(element) ) {
            element.forEach( element => {
                element.style.width = element.offsetWidth + 'px';
                element.style.height = element.offsetHeight + 'px';
                setTimeout( () => element.classList.add(cssClass), 5000);
            });
        } else {
            let padding = parseInt(window.getComputedStyle(element, null).getPropertyValue('padding'));
            

            if ( padding === 0 ) {
                element.setAttribute('initial-width', element.offsetWidth + 'px');
                element.setAttribute('initial-height', element.offsetHeight + 'px');
                width ? element.style.width = width + 'px' : element.style.width = element.offsetWidth + 'px';
                height ? element.style.height = height + 'px' : element.style.height = element.offsetHeight + 'px';
            } else {
                element.setAttribute('initial-width', element.offsetWidth - padding*2 + 'px');
                element.setAttribute('initial-height', element.offsetHeight - padding*2 + 'px');
                width ? element.style.width = width + 'px' : element.style.width = element.offsetWidth - padding*2 + 'px';
                height ? element.style.height = height + 'px' : element.style.height = element.offsetHeight - padding*2 + 'px';
            }
            !width && !height ? setTimeout( () => resolve(element.classList.add(cssClass)), 350) : false;
            
        }
    });
    let result = await promise;
}
//

// hang any function onClick by selector
function forEachClick ( selector = '', func = function(){} ) {
    [].forEach.call( document.querySelectorAll(selector), function(element) {
        element.onclick = function(event) {
            func(this)
        }
    });
}
//

// hang any function by selector
function forEachFunc ( selector = '', func = function(){} ) {
    document.querySelectorAll(selector).forEach( function(element) {
        func(element);
    });
}
//

// input element before #taskbar
function spawnHtml ( elementHTML = '', positionTop = 0, positionLeft = 0 ) {
    let taskbar = document.getElementById('taskbar-wrap');
    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    ( positionTop !== 0 ) ? elementHTML.style.top = positionTop + 'px' : false;
    ( positionLeft !== 0 ) ? elementHTML.style.left = positionLeft + 'px' : false;
}
//

// closing window on close button
function closeWindow ( element ) {
    element.onclick = async function(event) {
        let windowGreen = event.target.closest(".window-green"),
            windowTop = event.target.closest(".window-top"),
            windowHead = event.target.closest(".window-green").querySelector(".window-head"),
            windowBody = event.target.closest(".window-green").querySelector(".window-body"),
            windowHeader = event.target.closest(".window-green").querySelector(".wh-header")
        ;
        
        await animateWindow(windowGreen, "hide-background");
        await animateWindow(windowBody, "hide-height");
              animateWindow(windowGreen, "", 0, 25);
        await animateWindow(windowTop, "hide-width");
        await animateWindow(windowTop, "hide-padding");
        await animateWindow(windowTop, "hide-height");
        await animateWindow(windowBody, "hide-margin");
              animateWindow(windowBody, "hide-height");
              windowHead.style.position = "relative";
              animateWindow(windowHead, "hide-margin");
        
              animateWindow(windowGreen, "", windowHeader.offsetWidth + 10, 0);
              animateWindow(windowHead, "", windowHeader.offsetWidth + 10, 0);

        console.log(windowHeader.offsetWidth);
    }
}
//

// moving window by drug heading
let currentZindex = 5;
function windowsDraging ( windowHead ) {
    let currentWindow = windowHead.closest(".window-green");

    windowHead.onmousedown = function(e) {
        focusWindow(e.target.closest(".window-green"));
        let coords = getCoords(currentWindow),
            shiftX = e.pageX - coords.left,
            shiftY = e.pageY - coords.top
        ;
        currentWindow.style.position = 'absolute';
        moveAt(e);
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        
        function moveAt(e) {
            currentWindow.style.left = e.pageX - shiftX + 'px';
            currentWindow.style.top = e.pageY - shiftY + 'px';
        }
        document.onmousemove = function(e) {
            moveAt(e);
        };
        windowHead.onmouseup = function() {
            document.onmousemove = null;
            currentWindow.onmouseup = null;
        };

    }

    windowHead.ondragstart = function() {
        return false;
    };

    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
}
// hang draging function on elements
forEachFunc(".window-head", windowsDraging);
//

// main menu opening
document.getElementById("open-tasks").addEventListener( 'click' , function (event) {
    if ( document.getElementById("menu-wrap").classList.contains("active") ) {
        document.getElementById("menu-wrap").classList.remove("active");
        document.getElementById("button-toggle").style.top = '0';
    } else {
        document.getElementById("menu-wrap").classList.add("active");
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
});
//
// main menu closing
document.addEventListener( 'click' , function (event) {
    if ( document.getElementById("menu-wrap").classList.contains("active") && !event.target.closest("#menu-wrap") ) {
        document.getElementById("menu-wrap").classList.remove("active");
        document.getElementById("button-toggle").style.top = '0';
    }
});
//

// set margins inside taskbar
function setTasksMargin () {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = 0;
        taskbar = document.getElementById("taskbar"),
        itemsMargin = 0
    ;
    taskbar.style.overflow = 'hidden';
    taskbarItems.forEach( function (element) { 
        taskbarItemsWidth = taskbarItemsWidth + element.clientWidth;
    });

    itemsMargin = (taskbar.clientWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount ) - 1.5 ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    taskbarItems.forEach( function (element) { 
        element.style.margin = `0 ${itemsMargin}px`;
    });
    setTimeout(() => {
        taskbar.style.overflow = 'unset';
        taskbar.style.overflowY = 'hidden';
    }, 750);
    
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 9}px`;
}
//

// window focus in
function focusInWindow ( element, borderWidth ) {
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
    element.style.top = parseInt(element.style.top) - borderWidth + 'px';
    element.style.left = parseInt(element.style.left) - borderWidth + 'px';
}
//

// window focus out
function focusOutWindow ( activeElement, borderWidth ) {

    activeElement.style.top = parseInt(activeElement.style.top) + borderWidth + 'px';
    activeElement.style.left = parseInt(activeElement.style.left) + borderWidth + 'px';
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = '' ) {
    let element = document.querySelector(`.taskbar-item[task-name="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = '' || {} ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        } else {
            console.error('U dont have active elemnt to deactivate!');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    let activeElement = document.querySelector(".window-green.active"),
        borderWidth = parseInt(window.getComputedStyle(activeElement, null).getPropertyValue('border-width'))
    ;

    focusOutWindow(activeElement, borderWidth );
    deactivate('.taskbar-item.active');
    activateTaskInTaskbar(element.getAttribute('task-name'));
    focusInWindow(element, borderWidth);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element ) {
    if ( element.classList.contains("active") ) {
        return false;
    }
    focusWindow(document.querySelector(`.window-green[task-name="${element.getAttribute('task-name')}"]`));
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = {} ) {
    let menuElement = document.getElementById("task-list");
    jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
    });
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    forEachClick('.task-list-item', callWindow);
}
//

function removeMenuItem ( element = {}, menu = {} ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';

    function animation1(x) {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1.75s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2(x) {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3(x) {
        return new Promise(resolve => {
            element.remove();
            if (! menu.getElementsByTagName('ul')[0].getElementsByTagName('div')[0] ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
            setTimeout(() => {
                menu.style.marginLeft = menuML;
            }, 0);
            setTimeout(() => {
                menu.style.marginLeft = 0;
                menu.style.width = 0;
                menu.style.border = 0;
                menu.style.padding = 0;
                menu.style.overflow = 'hidden';
            }, 10);
                console.log(menuML);
            }
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element ) {
    let taskName = element.getAttribute('task-name'),
        taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap');
    let windowData = jsonWindowItemsData.tasks[taskId-1]; // like response
    
        removeMenuItem(element, menuBox);
        
        spawnHtml( spawnWindow(windowData) );
        spawnTask(windowData);
        setTasksMargin();
        forEachClick('.window-green.unhanged', focusWindow);
        forEachFunc(".window-head.unhanged", windowsDraging);
        document.querySelectorAll('.window-green.unhanged')[0].classList.remove('unhanged');
        // console.log(taskName);
        // console.log(taskId);
        // console.log(windowData);
}
//

// spawning window
function spawnWindow ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowData = windowObj.windowData;
    let windowHTML = `
            <div class="window-green unhanged" task-name="${taskName}" task-id="${taskId}" style="z-index: ${currentZindex++};">
                <div class="window-top">
                    <div class="window-minimize">
                        <div class="minimize-1"></div>
                        <div class="minimize-2"></div>
                    </div>
                    <div class="window-close">
                        <div class="close-line1"></div>
                        <div class="close-line2"></div>
                    </div>
                    <div class="window-line"></div>
                </div>
                <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                <div class="window-body">
                    ${windowData}
                </div>
            </div>
        `;
    return windowHTML;
}
//


// spawning task in taskbar
function spawnTask ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    
        let taskbar = document.getElementById('taskbar');
    return taskbar.insertAdjacentHTML('beforeend', elementHTML);
    
}
//















// functions to render page

forEachClick('.window-close', closeWindow);

// hang window focus handler on window
forEachClick('.window-green', focusWindow);
//

// hang window focus handler on taskbar item
forEachClick('.taskbar-item', focusWindowFromTB);
//

spawnRadar();

spawnMenuItems(jsonMenuItemsData);

setTasksMargin();
//













</script>
<script>
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</body>
</html>