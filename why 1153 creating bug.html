<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Decard Autumn</title>
</head>
<body>
    <div id="animated" style="position: absolute;left: 549.5px;">Hello there.</div>
    <button onclick="start()">Start</button>
    <button onclick="stop()">Stop</button>
        <script type="text/javascript">
            var elm = document.getElementById("animated");
            var stopped;
            var requestId = 0;
            var starttime;
    
            function render(time) {
                // set left style to a function of time.
              if (!stopped) {
                elm.style.left = ((Date.now() - starttime) / 4 % 600) + "px";
                requestId = window.requestAnimationFrame(render);
                }
                if (parseInt(elm.style.left) > 300) {
                    stop();
                }
            }
    
            function start() {
                starttime = Date.now();
                requestId = window.requestAnimationFrame(render);
                stopped = false;
            }
            function stop() {
                if (requestId) {
                    window.cancelAnimationFrame(requestId);
                }
                stopped = true;
            }
    </script>
    <!-- <div id="triger">Click here</div> -->
    <div id="taskbar-wrap">
        <div id="menu-wrap">
            <div id="open-tasks">
                <div id="button-toggle">
                    <div id="open-menu">Open</div>
                    <div id="close-menu" style="height: 0px;">Close</div>
                </div>
                <div class="menu-text">menu</div>
            </div>
        <ul id="task-list">
            
        </ul>

        </div>
        
        <div id="taskbar">
            <div id="taskbar-inner">
                <div class="taskbar-item-empty">
                    This is a taskbar, open menu and start your task...
                </div>
            </div>
        </div>
        <div id="taskbar-overlay"></div>
    </div>

<script type="text/javascript" src="menuItemsResponse.js"></script> <!-- json response whit menu data-->
<script type="text/javascript" src="menuWindowsResponse.js"></script> <!-- json response whit windows data-->
<script id="main-script">
// generating array with composite numbers
function spawnRadarVals (size = 5) {
    let radarVals = [];
    if ( size % 2 === 0 ) return size;
    for (let i = 0; radarVals.length < size*size; i++) {
        // first exeptions
        if (i == 1 || i == 0) radarVals.push(i);
        // push composite nums
        for (let j = 2; j < i;) {
            if (i % j++ === 0) {
                radarVals.push(i);
                break;
            }
        }
    }
    return radarVals;
}
//

// transition simple array with nums into object with decard coords
function radarToDecard ( radarVals = spawnRadarVals() ) {
    if ( !Array.isArray(radarVals) ) return 'radarVals must be array. Your data - ' + radarVals;
    let x = 0,
        y = 0,
        comment = '',
        decard = {},
        step = 1,
        stepsCount = 0,
        ratationX = 0,
        ratationY = 1
    ;
    radarVals.forEach(element => {
        if ( element === 0 ) {
            decard[element] = { // first element is Base
                x: 0,
                y: 0,
                comment: 'Base'
            };
            return true;
        }
            if /*--*/ ( ratationX === 0 && ratationY === 1 ) { // Up
                y++;
                if ( stepsCount === 0 && element !== radarVals[1] ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === 1 && ratationY === 0 ) { // Right
                x++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = -1;
                    stepsCount = 0;
                }
            } else if ( ratationX === 0 && ratationY === -1 ) { // Down
                y--;
                if ( stepsCount === 0 ) step++;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = -1;
                    ratationY = 0;
                    stepsCount = 0;
                }
            } else if ( ratationX === -1 && ratationY === 0 ) { // Left
                x--;
                stepsCount++;
                if ( step === stepsCount ) {
                    ratationX = 0;
                    ratationY = 1;
                    stepsCount = 0;
                }
            }
            decard[element] = {
                x: x,
                y: y
            };
        
    });
    return decard;
}
//

// object with functions to init window interface
let functionsToInitWindow = {};
//

// spawning radar matrix
function spawnRadar ( radarObj = radarToDecard(spawnRadarVals(11)) ) {
    let radarElemnt = document.getElementById("matrix-graph"),
        prevX = null
    ;
        radarElemnt.innerHTML = '';
    for (let value in radarObj) {
        let x = radarObj[value].x,
            y = radarObj[value].y,
            afterBegin = 'afterBegin',
            currRow = document.querySelector(`[row-decard-y="${y}"]`),
            spawnX = (  ) => {
                if ( currRow.firstChild !== null ) {
                    x < currRow.firstChild.getAttribute('decard-x') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                }

                currRow.insertAdjacentHTML(afterBegin, `<td decard-x="${x}" decard-y="${y}">${value}</td>`);
            }
        ;

        if ( !currRow ) { // spawn first Y row
            if ( radarElemnt.firstChild == null ) {
                let newRow = document.createElement('tr');
                newRow.setAttribute('row-decard-y', y);
                radarElemnt.prepend(newRow);
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
                currRow.firstChild.classList.add('base');
            } else { // spawn Y rows
                if ( !document.querySelector(`[row-decard-y="${y}"]`) ) {
                    y > radarElemnt.firstChild.getAttribute('row-decard-y') ? afterBegin = 'afterBegin' : afterBegin = 'beforeEnd';
                    radarElemnt.insertAdjacentHTML(afterBegin, `<tr row-decard-y="${y}" "></tr>`);
                }
                currRow = document.querySelector(`[row-decard-y="${y}"]`);
                spawnX();
            }
        } else if ( currRow ) {
                spawnX();
        } else {
            console.log('Something wrong with Y row. His value :');
            // console.log(currRow);
        }
    }
}
function initRadar( number = 5 ) {
    spawnRadar(radarToDecard(spawnRadarVals(number)));
}
functionsToInitWindow['initRadar'] = initRadar;
//

// render matrix on submit button in task window
function initFormMatrixSubmit() {
    let form = document.getElementById("matrix-form");
    form.onsubmit = function () {
        let number = document.getElementById("matrix_size").value;
        spawnRadar( radarToDecard( spawnRadarVals(number) ) );
        document.getElementById("matrix-graph").closest(".window-green").style.zIndex = currentZindex++;
        return false;
    };
}

functionsToInitWindow['initFormMatrixSubmit'] = initFormMatrixSubmit;
//

// helpers START

// function blocker clicks on active animation
function blockClicked ( element = {}, time = 0 ) {
    element.classList.add("blocked");
    let blockedTimeOut = setTimeout(() => {
        element.classList.remove("blocked");
    }, time);
}
//

// checking object for emptiness
function isEmptyObject ( rest = {} ) {
    return ( Object.keys(rest).length === 0 && rest.constructor === Object ) ?  true :  true;
}
//

// checking unexpected params in function, if have throw error
function unexpectedParams(rest) {
    if ( !isEmptyObject(rest) ) throw new TypeError( message = 'Unexpected params given:' + JSON.stringify(rest) );
}
//

// hang any function onClick by selector
function forEachClick (
    {
        selector          = '',
        func              = Function,
        needTimeOut       = false,
        secTimeOut        = 0,
        selectorToBlocked = '',
        ...rest
    }
) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or u pass not a Function");
        if ( typeof needTimeOut !== 'boolean' ) throw new TypeError("U pass not Boolean in 'needTimeOut'");
        if ( typeof secTimeOut !== 'number' ) throw new TypeError("U pass not Number in 'secTimeOut'");
        if ( secTimeOut < 0 ) throw new TypeError("Ur Number - 'secTimeOut' is lower then 0");
        if ( needTimeOut !== false && typeof selectorToBlocked !== 'string' ||
             needTimeOut !== false && selectorToBlocked === '' ||
             needTimeOut !== false && !document.querySelectorAll(selectorToBlocked)[0]
            ) throw new ReferenceError("U pass not String in 'selectorToBlocked' or it wasn't found");
        unexpectedParams(rest);

        [].forEach.call( document.querySelectorAll(selector), function(element) {
            element.onclick = function(event) {
                if ( element.classList.contains("blocked") || element.closest(".blocked") === null ) {
                    func(this, event);
                    if ( needTimeOut ) {
                        blockClicked(document.querySelectorAll(selectorToBlocked)[0], secTimeOut);
                    }
                }
            }
        });
    } catch (err) {
        console.error(err);
    }
}
//

// hang any function by selector
function forEachFunc ( selector = '', func = Function ) {
    try {
        if ( typeof selector !== 'string' ||
             selector === '' ||
             !document.querySelectorAll(selector)[0]
            ) throw new ReferenceError("U pass not String in 'selector' or it wasn't found");
        if ( func == Function || typeof func !== 'function') throw new TypeError("U didn't pass the 'func', or it's not a Function");

        document.querySelectorAll(selector).forEach( function(element) {
            func(element);
        });
    } catch (err) {
        console.error(err);
    }
}
//

// array with selectors and functions when click outside it, hanged on document event click
let outsideElements = [];

function setOutsideClick ( selector = '', parent = '', funCall = Function ) {
    try {
        if ( typeof selector !== 'string' ) throw new TypeError("U pass not String in 'selector'");
        if ( typeof parent !== 'string' ) throw new TypeError("U pass not String in 'parent'");
        if (!document.querySelectorAll(selector)[0]) throw new ReferenceError("Ur 'selector' wasn't found");
        if (!document.querySelectorAll(parent)[0]) throw new ReferenceError("Ur 'parent' wasn't found");
        if ( funCall == Function || typeof funCall !== 'function') throw new TypeError("U didn't pass the 'funCall', or u pass not a Function");

        outsideElements.push({
            selector: selector,
            parent: parent,
            funCall: funCall
        });
        
    } catch (err) {
        console.error(err);
    }
}

function clickOutside ( outsideElements = [] ) {
    outsideElements.forEach( function(element) {
        if ( document.querySelectorAll(element.selector)[0].classList.contains("active") && !event.target.closest(element.parent) ) {
            element.funCall();
            console.warn('click outside element in array');
        }
    });
}

document.addEventListener( 'mousedown' , function (event) {
    clickOutside(outsideElements);
});
//

// set crosBrowser transform style
function setTransformStyle ( element = {}, value = '' ) {
    try {
        element.style.webkitTransform = value;
        element.style.mozTransform = value;
        element.style.msTransform = value;
        element.style.oTransform = value;
        element.style.transform = value;
        return true;
    } catch (err) {
        console.error(err);
        return false;
    }
}
//

// set window on center
function setWindowOnCenter( element = {} ) {
    setTransformStyle(element, 'translate(-50%, -50%)');
    element.style.top = '50%';
    element.style.left = '50%';

    let elementPositions = element.getBoundingClientRect(),
        taskBarHeight = document.getElementById("taskbar-overlay").offsetHeight,
        borderWidthSingle = parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--border-width') ) / 2
    ;
    element.style.top = 
        ( elementPositions.top < borderWidthSingle + taskBarHeight ) ?
            borderWidthSingle + 'px'
                :
            elementPositions.top - taskBarHeight + 'px'
    ;
    element.style.left = 
        ( window.innerWidth - element.offsetWidth > elementPositions.left ) ?
            elementPositions.left + 'px'
                :
            borderWidthSingle + 'px' 
    ;
    
    setTransformStyle(element, 'unset');
}
//

// animation scale 0 to 1
function transformAnimation (
    {
        element        = undefined,
        transition     = '1.00s',
        transitionEnd  = '',
        transformFrom  = 'scale(0)',
        transformTo    = 'scale(1)',
        transformEnd   = '',
        classToRemove  = '',
        classToAdd     = '',
        ...rest
    }
) {
    try {
        if (!element) throw new TypeError("U didn't pass the element");
        unexpectedParams(rest);

        
        setTransformStyle(element, transformFrom);
        blockClicked(element, parseFloat(transition) * 1000 + 1);
        
        setTimeout(() => {
            element.style.transition = transition;
            setTransformStyle(element, transformTo);
        }, 1);
        setTimeout(() => {
            if ( transitionEnd ) element.style.transition = transitionEnd;
            if ( classToRemove ) element.classList.remove(classToRemove);
            if ( transformEnd ) setTransformStyle(element, transformEnd);
            if ( classToAdd ) element.classList.add(classToAdd)
        }, parseFloat(transition) * 1000 + 1 );
    } catch (err) {
        console.error(err);
    }
}
//

// input element before #taskbar
function spawnHtml ( [elementHTML = '', selector = '', positionTop = 0, positionLeft = 0] ) {
    let taskbar = document.getElementById('taskbar-wrap')
        element = false;

    taskbar.insertAdjacentHTML('beforebegin', elementHTML);
    
    if ( selector !== '' && document.querySelectorAll(selector)[0] ) {
        element = document.querySelectorAll(selector)[0];
        ( positionTop !== 0 ) ? element.style.top = positionTop + 'px' : false;
        ( positionLeft !== 0 ) ? element.style.left = positionLeft + 'px' : false;
    }
    return element;
}
//

// get usable html height (html - taskbar)
function getUsableHeight () {
    return window.innerHeight - document.querySelector("#taskbar-overlay").offsetHeight;
}
//
// debounce function
function debounce(func, timeout = 300){
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => { func.apply(this, args); }, timeout);
  };
}
//

// helpers END

// removing window, showing menu item, show/hide menu on close button
function closeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        menuElement = document.querySelectorAll(`.task-list-item.hidden[task-id="${taskId}"]`)[0],
        menuWrap = document.getElementById("menu-wrap")
    ;
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)'
    });
    transformAnimation({
        element: elementInTaskBar,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'mg0imp'
    });
        setTasksMargin();
        menuElement.style.margin = '';
        menuElement.style.transform = 'scale(1)'; 
        menuElement.style.height = '';
        menuElement.style.transition = '0s';

    if ( menuWrap.querySelectorAll(".task-list-item.hidden").length == menuWrap.querySelectorAll(".task-list-item").length ) {
        menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');
        document.getElementById("taskbar").style.right = '';
    } else {
        menuWrap.style.transition = '0s';
                
        setTimeout(() => {
            menuWrap.style.transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition');

        }, 1 );
    }

    menuElement.classList.remove("hidden");
    initializeMenu();

    setTimeout(() => {
        windowElement.remove();
        elementInTaskBar.remove();
        setTasksMargin();
        if ( !document.querySelectorAll(".taskbar-item")[0] ) {
            document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 1;
        }

    }, parseFloat(transition) * 1000 );
}
//

// minimizing window, set inactive menu item
function minimizeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition'),
        taskId = windowElement.getAttribute('task-id'),
        elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        windowRect = windowElement.getBoundingClientRect()
    ;

    windowElement.setAttribute('prev-top', windowElement.style.top);
    windowElement.setAttribute('prev-left', windowElement.style.left);
    windowElement.style.transition = '1s';
    windowElement.style.top = taskBarElementRect.top + 'px';
    windowElement.style.left = taskBarElementRect.left - windowRect.width/2 + 'px';

    setTimeout(() => {
        elementInTaskBar.classList.remove('active');
    }, parseFloat(transition) * 1000);

    // console.log(elementInTaskBar.getBoundingClientRect());

    // .getBoundingClientRect()
    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(1)',
        transformTo:  'scale(0)',
        classToAdd: 'minimized'
    });
}
//

// maximizing window, set inactive menu item
function maximizeWindow ( element = undefined ) {
    let windowElement = element.closest(".window-green"),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--default-transition')
        // taskId = windowElement.getAttribute('task-id'),
        // elementInTaskBar = document.querySelectorAll(`.taskbar-item[task-id="${taskId}"]`)[0],
        // taskBarElementRect = elementInTaskBar.getBoundingClientRect(),
        // windowRect = windowElement.getBoundingClientRect()
    ;


    windowElement.style.top = windowElement.getAttribute('prev-top');
    windowElement.style.left = windowElement.getAttribute('prev-left');

    setTimeout(() => {
        windowElement.style.transition = '';
    }, parseFloat(transition) * 1000 + 1);

    
    transformAnimation({
        element: windowElement,
        transition: transition,
        transformFrom: 'scale(0)',
        transformTo:  'scale(1)',
        classToRemove: 'minimized'
    });
}
//

// showing ghost window for maximizing
let currentZindex = 5;

// remove ghost window for mouseup
function removeGhost( id = 0 ) {
    let selector = `#ghost-window-${id}`,
        ghost = document.querySelector(selector),
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        timeout = parseFloat(transition) * 1000 + 1;
    if ( ghost ) {
        ghost.style.transition = transition;
        ghost.style.width = 0;
        ghost.style.height = 0;
        ghost.style.opacity = 0;
        console.log(getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'));
        console.log(timeout);
        ghost.style.left = ghost.getAttribute('mouse-position') + 'px';
        
        setTimeout(() => {
            if (document.querySelector(selector)) document.querySelector(selector).remove();
        }, timeout);
    }
}
//
function clearGhosts() {
    // if (document.querySelector(`#ghost-window-${ghostWindowId}`)) removeGhost(ghostWindowId);
    document.querySelectorAll(".ghost-window").forEach( item => item.remove() );
    ghostWindowId++;
}


let animations = {},
    animatedProps = {};

function animateByPixel({
    duration = 750, // ms
    timing = {},
    draw = {},
    styleObj = {},
    property = 'width',
    number   = 1,
    timeInPx = 1,
    summation = true,
    subtraction = false
    }) {

    let start = performance.now(),
            fisrstCount = parseInt(styleObj.style[property]);

   
    animations[property] = window.requestAnimationFrame(function animateByPixel(time) {
    // timeFraction от 0 до 1
        let timeFraction = (time - start) / duration;
        if (timeFraction > 1) timeFraction = 1;

        // if ( animations[0] !== undefined ) animations.forEach(function(){window.cancelAnimationFrame(this)});
    // setTimeout(() => {
    //     number = 450;
    //     // сделай обьект снаружи с размерами в который будешь изменять значения при увеличении/уменьшении окна во время работы анимации,
    //     // и в анимацию брать конечный размер снаружи
    // }, 1500);

        // текущее состояние анимации
        let progress = time - start,
            size,
            obj = animatedProps[property];
        // console.log(timeFraction);

        console.log(animatedProps);
        if ( !animatedProps[property] )animatedProps[property] = {};
        if ( !animatedProps[property].previous ) animatedProps[property].previous = 0;
        

        
        if ( !animatedProps[property].end) animatedProps[property].end = number;
        // size = obj.end - obj.startedSize;
        animatedProps[property].timeLeft = Math.floor(duration - duration * timeFraction);
        // animatedProps[property].current = animatedProps[property].previous + Math.floor( (animatedProps[property].end - animatedProps[property].previous) * timeFraction);
        animatedProps[property].current = animatedProps[property].end* timeFraction;
        styleObj.style[property] = animatedProps[property].end* timeFraction  + 'px';
        // console.log(animatedProps[property].end);
        // console.log(animatedProps[property].current);
        styleObj.setAttribute('time-fraction', animatedProps[property].timeLeft);

        // animatedProps.width.end  = animatedProps.width.end + animatedProps.width.end - animatedProps.width.startedSize;
        // if (summation) {
        //     if (  number * timeFraction > fisrstCount ){
        //         styleObj.style[property] = number * timeFraction + 'px';
        //     }
        // } else if (subtraction) {
        //     if (  number * timeFraction > fisrstCount ){
        //         styleObj.style[property] = number * timeFraction + 'px';
        //     }
        // }

        if (timeFraction < 1) {
            animations[property] = window.requestAnimationFrame(animateByPixel);
        }
    });
}

function cancel() {
    for (const key in animations) {
        if (Object.hasOwnProperty.call(animations, key)) {
            const element = animations[key];
            console.log(animations[key]);
            window.cancelAnimationFrame(animations[key]);
        }
    }
    // animatedProps = {};
    animations = {};
    // animations.forEach( function (item, index, array) {
    //     window.cancelAnimationFrame(item);
    //     animations.splice(index, 1);
    //     console.log(animations);
    //     animations[item];
    // });
    () => callback();
    return;
}
function showGhost({
    id        = 0,
    width     = 250,
    height    = 250,
    posLeft   = -9999,
    posTop    = -9999,
    posBott   = -9999,
    fromTo    = false,
    toIfExist = false,
    useBottom = false,
    posToLeft = -9999,
    posToTop  = -9999,
    posToBott = -9999,
    instantTrans = false,
    ...rest
    }) {
    unexpectedParams(rest);
    if ( useBottom ) posTop = undefined, posToTop = undefined;
    if ( document.querySelector(`#ghost-window-${id}`) !== null && !toIfExist ) {
        // console.log("toIfExist === false; already exist");
        return;
    } else if ( document.querySelector(`#ghost-window-${id}`) !== null && toIfExist ) {
        let ghostWindowElement = document.querySelector('#ghost-window-'+id);
        ghostWindowElement.style.right = posToLeft+'px';

        // let timmeout = setTimeout(() => {
                


        
        // animatedProps[property].end = number;
        // size = obj.end - obj.startedSize;
        // animatedProps[property].timeLeft = Math.floor(duration - duration * timeFraction);
        // animatedProps[property].current = animatedProps[property].previous + Math.floor( (animatedProps[property].end - animatedProps[property].previous) * timeFraction);
        
        // ghostWindowElement.style.width = (animatedProps.width.end*2 - animatedProps.width.startedSize) +  'px';

        console.log(width - animatedProps.width.startedSize);
        console.log();
        animatedProps.width.end = width;
        // animatedProps.width.end  = animatedProps.width.end + animatedProps.width.end - animatedProps.width.startedSize;
        // let timer;
        // clearTimeout(timer);
        // timer = setTimeout(() => { 
        //     cancel();
        //     animatedProps.width.previous = animatedProps.width.current;
        //     animateByPixel({ duration: ghostWindowElement.getAttribute('time-fraction'), styleObj: ghostWindowElement, property: 'width', number: width, summation: true });
        // }, 20);

        // animateByPixel({ duration: ghostWindowElement.getAttribute('time-fraction'), styleObj: ghostWindowElement, property: 'height', number: height,  summation: true });

        //     clearTimeout(timmeout);
        // }, ghostWindowElement.getAttribute('time-fraction'));
        //     console.log('animations');
        
        // animateByPixel({ styleObj: ghostWindowElement.style, property: 'width', number: width, summation: true });
        // ghostWindowElement.style.width = width+'px';
        // console.log(animations);
        setTimeout(() => {
            
            if ( !ghostWindowElement.classList.contains('first-move') && instantTrans ) {
                setTimeout(() => {
                    ghostWindowElement.style.left = posToLeft +'px';
                    ghostWindowElement.style.width = width +'px';
                    ghostWindowElement.style.transition = `all 0s`;
                    console.log('trnas-unblocked');
                }, 6);
            }
            if ( ghostWindowElement.classList.contains('first-move') || !instantTrans ) {

                if ( posToLeft !== -9999 ) ghostWindowElement.style.left = posToLeft +'px';
                if ( posToTop  !== -9999 ) ghostWindowElement.style.top = posToTop +'px';
                if ( posToBott !== -9999 ) ghostWindowElement.style.bottom = posToBott +'px';
                ghostWindowElement.style.width = width +'px';
                ghostWindowElement.style.height = height +'px';
                ghostWindowElement.classList.remove('first-move');
            }

        }, 6);
        return;
    }
    if ( !fromTo ) { // if false - default
        let ghostWindow = `
            <div id="ghost-window-${id}" class="ghost-window"
                style="z-index: ${currentZindex - 2};
                left: ${ (posLeft !== -9999) ? posLeft : '' }px;
                top: ${ (posTop !== -9999) ? posTop : '' }px;
                bottom: ${ (posBott !== -9999) ? posBott : '' }px;"
                mouse-position="${posLeft}">
            </div>`
        ;
        document.querySelector("body").insertAdjacentHTML('beforeEnd', ghostWindow);
        
        let ghostWindowElement = document.querySelector('#ghost-window-'+id);

        // console.log('fromTo === false');
        setTimeout(() => {
            ghostWindowElement.style.left = '0px';
            ghostWindowElement.style.top = '0px';
            ghostWindowElement.style.bottom = '0px';
            ghostWindowElement.style.width = width +'px';
            ghostWindowElement.style.height = height +'px';
        }, 5);

    } else if ( fromTo ) {
        let ghostWindow = `
            <div id="ghost-window-${id}" class="ghost-window"
                style="
                    z-index: ${currentZindex - 2};
                    right:   ${ (posLeft !== -9999) ? posLeft : '' }px;
                    top:     ${ (posTop  !== -9999) ? posTop  : '' }px;
                    bottom:  ${ (posBott !== -9999) ? posBott : '' }px;
                    width: 0px;
                    height: 0px;
                "
                mouse-position="${posLeft}">
            </div>`
        ;
        document.querySelector("body").insertAdjacentHTML('beforeEnd', ghostWindow);
        
        let ghostWindowElement = document.querySelector('#ghost-window-'+id);

        let x = 125;
        let a = (width/x >= 1) ? Math.round(width/x) : 1,
            b = (height/x >= 1) ? Math.round(height/x) : 1,
            c = (posLeft/x >= 1) ? Math.round(posLeft/x) : 1;
        console.log(a);
        console.log(b);
        console.log('fromTo === true');
        console.log(width);
        console.log(height);
        // console.log(c);
        animatedProps.width = {};
        animatedProps.width.startedSize = width;
        // animatedProps.width.startedMouse = width;
        // console.log(animateByPixel({ styleObj: ghostWindowElement, property: 'width', number: width, summation: true }));
        // console.log(animateByPixel({ styleObj: ghostWindowElement, property: 'height', number: height,  summation: true }));
        // animateByPixel({ styleObj: ghostWindowElement.style, property: 'right', number: posToLeft, subtraction: true });
        // animateByPixel({ styleObj: ghostWindowElement.style, property: 'bottom', number: 70, timeInPx: 1, subtraction: true });
        // animatePixels(ghostWindowElement.style, 'height', height);
        // animatePixels(ghostWindowElement.style, 'right', posToLeft, false);
        // animatePixels(ghostWindowElement.style, 'top', posToTop, false);
        // let timerId = setTimeout(function tick() {
        //     if ( parseInt(ghostWindowElement.style.width) >= width ) {
        //         if ( parseInt(ghostWindowElement.style.width) !== width ) ghostWindowElement.style.width = width+'px'; 
        //         return;
        //     }
        //     ghostWindowElement.style.width = parseInt(ghostWindowElement.style.width) + 25 + 'px';
        //     timerId = setTimeout(tick, 1); // (*)
        // }, 1);
        // let timerId2 = setTimeout(function tick() {
        //     if ( parseInt(ghostWindowElement.style.height) >= height ) {
        //         if ( parseInt(ghostWindowElement.style.height) !== height ) ghostWindowElement.style.height = height+'px'; 
        //         return;
        //     }
        //     ghostWindowElement.style.height = parseInt(ghostWindowElement.style.height) + 25 + 'px';
        //     timerId2 = setTimeout(tick, 1); // (*)
        // }, 1);
        
        
        // let timerId3 = setTimeout(function tick() {
        // if ( parseInt(ghostWindowElement.style.right) <= posToLeft ) {
        //     if ( parseInt(ghostWindowElement.style.right) !== posToLeft ) ghostWindowElement.style.right = posToLeft+'px'; 
        //     return;
        // }
        //     ghostWindowElement.style.right = parseInt(ghostWindowElement.style.right) - 25 + 'px';
        //     timerId3 = setTimeout(tick, 1); // (*)
        // }, 1);
        // let timerId4 = setTimeout(function tick() {
        // if ( parseInt(ghostWindowElement.style.top) <= posToTop ) {
        //     if ( parseInt(ghostWindowElement.style.top) !== posToTop ) ghostWindowElement.style.top = posToTop+'px'; 
        //     return;
        // }
        //     ghostWindowElement.style.top = parseInt(ghostWindowElement.style.top) - 25 + 'px';
        //     timerId4 = setTimeout(tick, 1); // (*)
        // }, 1);

        if ( posToLeft !== -9999 ) ghostWindowElement.style.left = posToLeft +'px';
        if ( posToTop  !== -9999 ) ghostWindowElement.style.top = posToTop +'px';
        if ( posToBott !== -9999 ) ghostWindowElement.style.bottom = posToBott +'px';
        ghostWindowElement.classList.add('first-move');
            
    }
}

// moving window by drug heading,
let ghostWindowId = 0; // global variable for index of ghost windows
function windowsDraging ( windowHead = {} ) {
    function getCoords(elem) {
        let box = elem.getBoundingClientRect();
        return {
            top: box.top + pageYOffset,
            left: box.left + pageXOffset
        };
    }
    let currentWindow = windowHead.closest(".window-green");
    windowHead.onmousedown = function(event) {
        focusWindow(event.target.closest(".window-green"));
        let mouseDownEvent = event,
            coords = getCoords(currentWindow),
            shiftX = event.pageX - coords.left,
            shiftY = event.pageY - coords.top,
            ghostMargin = parseInt( getComputedStyle(document.documentElement).getPropertyValue('--ghost-window-margin') ),
            usableWidth = window.innerWidth,
            usableHeight = getUsableHeight(),
            ghostWidth = usableWidth - ghostMargin*2,
            ghostHeight = usableHeight- ghostMargin*2,
            ghostHalfWidth = ghostWidth / 2 - ghostMargin,
            ghostHalfHeight = ghostHeight / 2 - ghostMargin,
            posHalfBottom = usableHeight - ghostHeight / 2 - ghostMargin,
            posHalfLeft = usableWidth - ghostWidth / 2 - ghostMargin,
            needModal = false,
            taskbarOverlay = document.querySelector("#taskbar-overlay"),
            maximizeTop = 150,
            maximizeBottom = 150

        ;
        function moveAt(event) {
            currentWindow.style.left = event.pageX - shiftX + 'px';
            currentWindow.style.top = event.pageY - shiftY + 'px';
        }
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        document.querySelector("html").style.userSelect = 'none';
        
        document.onmousemove = function(event) {
            taskbarOverlay.style.zIndex = '9999';
            moveAt(event);
            // when mouse moves outside usable area
            if ( event.pageY < 0 ){ // top
                windowHead.onmouseup();
                currentWindow.style.top = '0px';
                outsideAlert('Do it', ghostWindowId);
            } else if ( event.pageY > innerHeight ){ // bottom when not full screen mode
                console.log(usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 +
                document.querySelector(".window-head").offsetHeight + 5);
                currentWindow.style.top = 
                usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 -
                document.querySelector(".window-head").offsetHeight + 5 + 'px';
                windowHead.onmouseup();
                outsideAlert('Mouse outside document', ghostWindowId);
            } else if ( event.target == taskbarOverlay ) { // bottom when inside browser but hovered at taskbar
                taskbarOverlay.style.cursor = 'pointer';
                taskbarOverlay.onmouseup = function(event) {
                    console.log(usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 +
                    document.querySelector(".window-head").offsetHeight + 5);
                    currentWindow.style.top = 
                    usableHeight - parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width'))*2 -
                    document.querySelector(".window-head").offsetHeight + 5 + 'px';
                    windowHead.onmouseup();
                }
            }
            // show ghost window when mouse close to outside
            if ( parseInt(currentWindow.style.top) <= 0 ) { // top border
                if ( event.pageX < maximizeTop ) { // left
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: 0,
                        posToTop : 0
                    });
                } else if ( usableWidth - event.pageX < maximizeTop ) { // right
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : event.pageX,
                        posTop   : 0,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: usableWidth-ghostWidth/2-ghostMargin,
                        posToTop : 0
                    });
                } else { // middle
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostWidth,
                        height   : ghostHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : false,
                        toIfExist: true,
                        posToLeft: 0,
                        posToTop : 0
                    });
                }
            } else if ( event.pageX < 5 ) { // left border
                let left = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageX : 0,
                    topBottom = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY: usableHeight - ghostHeight/2-ghostMargin,
                    top = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY : 0;
                if ( event.pageY < maximizeTop ) { // top
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: 0,
                        posToTop : 0
                    });
                } else if ( usableHeight - event.pageY < maximizeTop ) { // bottom
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : 0,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: 0,
                        posToTop : posHalfBottom
                    });
                } else { // middle
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHeight,
                        posLeft  : 0,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: 0,
                        posToTop : 0
                    });
                }
            } else if ( event.pageX + 5 > usableWidth ) { // right border
                let topBottom = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY: usableHeight - ghostHeight/2-ghostMargin,
                    top = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageY : 0,
                    left = (document.querySelector(`#ghost-window-${ghostWindowId}`) == null) ? event.pageX : usableWidth - ghostWidth/2-ghostMargin;
                if ( event.pageY < maximizeTop ) { // top
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: posHalfLeft,
                        posToTop : 0
                    });
                } else if ( usableHeight - event.pageY < maximizeTop ) { // bottom
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHalfHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: posHalfLeft,
                        posToTop : posHalfBottom
                    });
                } else { // middle
                    showGhost({
                        id       : ghostWindowId,
                        width    : ghostHalfWidth,
                        height   : ghostHeight,
                        posLeft  : event.pageX,
                        posTop   : event.pageY,
                        fromTo   : true,
                        toIfExist: true,
                        posToLeft: posHalfLeft,
                        posToTop : 0
                    });
                }
            } else {
                clearGhosts();
            }
        }
        windowHead.onmouseup = function() {
            if (parseInt(currentWindow.style.top) < 0) currentWindow.style.top = '0px';
            clearGhosts();
            document.onmousemove = null;
            document.querySelector("html").style.userSelect = '';
            currentWindow.onmouseup = null;
            taskbarOverlay.onmouseup = null;
            taskbarOverlay.style.zIndex = '';
            if ( taskbarOverlay.style.cursor == 'pointer' ) taskbarOverlay.style.cursor = '';
        }
    }
    windowHead.ondragstart = function() {
        console.log(1);
    }
}
//

// hadler for all borders to resize
const borders = {
    ".window-border-top": {
        selector: ".window-border-top",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: true,
        isPositive: true
    },
    ".window-border-top-right" : {
        selector: ".window-border-top-right",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: true,
        isPositive: true
    },
    ".window-border-right": {
        selector: ".window-border-right",
        borderX: true,
        borderY: false,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-bottom": {
        selector: ".window-border-bottom",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-bottom-left": {
        selector: ".window-border-bottom-left",
        borderX: false,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    },
    ".window-border-left": {
        selector: ".window-border-left",
        borderX: true,
        borderY: false,
        moveX: true,
        moveY: false,
        isPositive: true
    },
    ".window-border-top-left": {
        selector: ".window-border-top-left",
        borderX: true,
        borderY: true,
        moveX: true,
        moveY: true,
        isPositive: true
    },
    ".window-border-bottom-right": {
        selector: ".window-border-bottom-right",
        borderX: true,
        borderY: true,
        moveX: false,
        moveY: false,
        isPositive: false
    }
};

document.onmousedown = function(event) {
    Object.keys(borders).forEach(function(selector) {
        if (
            event.target !== document.querySelector(selector)
        ) {
            return false;
        }
    // item.element.onmousedown = function(event) {
        let item = borders[selector],
            mouseDownEvent = event,
            currentWindow = event.target.closest(".window-green"),
            bordersWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--border-width')),
            taskBarHeigth = document.getElementById("taskbar-overlay").offsetHeight,
            ghostMargin = parseInt( getComputedStyle(document.documentElement).getPropertyValue('--ghost-window-margin') ),
            usableWidth = window.innerWidth,
            usableHeight = getUsableHeight(),
            defaultGhostW = usableWidth - ghostMargin*2,
            defaultGhostH = usableHeight - ghostMargin*2,
            clickPosLeft = event.x,
            clickPosTop = event.y,
            windowWidth = currentWindow.offsetWidth,
            windowHeight = currentWindow.offsetHeight,
            bordersElement = currentWindow.querySelector(".window-borders"),
            windowBodyElement = currentWindow.querySelector(".window-body"),
            coords = getCoords(currentWindow),
            shiftX = event.pageX - coords.left,
            shiftY = event.pageY - coords.top,
            windowBodyHeight = windowBodyElement.clientHeight - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding')),
            windowBodyWidth = windowBodyElement.offsetWidth - 2*parseInt(getComputedStyle(windowBodyElement).getPropertyValue('padding')),
            taskbarOverlay = document.querySelector("#taskbar-overlay"),
            counter = 300
        ;
        document.querySelector("html").style.userSelect = 'none'; 
        taskbarOverlay.style.zIndex = '9999';

        function getCoords(elem) {
            let box = elem.getBoundingClientRect();
            return {
                top: box.top + pageYOffset,
                left: box.left + pageXOffset
            };
        }

        function moveAt( event, moveX, moveY ) {
            if (moveX) currentWindow.style.left = event.pageX - shiftX + 'px';
            if (moveY) currentWindow.style.top = event.pageY - shiftY + 'px';
        }

        function changeSize( event, borderX, borderY, isPositive ) {
            let diffX = clickPosLeft - event.pageX,
                diffY = clickPosTop - event.pageY;
            bordersElement.style.transition = '0s';
            windowBodyElement.style.transition = '0s';

            
            if ( borderX && isPositive ) {
                currentWindow.style.width = windowWidth + diffX + 'px';
                bordersElement.style.width = windowWidth + diffX + 'px';
                windowBodyElement.style.width = windowBodyWidth + diffX + 'px';
            } else if ( borderX && !isPositive ) {
                currentWindow.style.width = windowWidth - diffX + 'px';
                bordersElement.style.width = windowWidth - diffX + 'px';
                windowBodyElement.style.width = windowBodyWidth - diffX + 'px';
            }
            
            if ( borderY && isPositive ) {
                currentWindow.style.height = windowHeight + diffY + 'px';
                bordersElement.style.height = windowHeight + diffY + 'px';
                windowBodyElement.style.height = windowBodyHeight + diffY + 'px';
            } else if ( borderY && !isPositive ) {
                currentWindow.style.height = windowHeight - diffY + 'px';
                bordersElement.style.height = windowHeight - diffY + 'px';
                windowBodyElement.style.height = windowBodyHeight - diffY + 'px';
            }
            
        }

        focusWindow(event.target.closest(".window-green"));
        currentWindow.style.zIndex = currentZindex++; // z-index priority
        // console.log();
        // console.log();
        document.onmousemove = function(event) {
            let pxsToTaskBar = usableHeight - parseInt(currentWindow.style.top) - currentWindow.offsetHeight,
                clickedClass = mouseDownEvent.target.classList[0];
            document.querySelector("html").style.cursor = getComputedStyle(mouseDownEvent.target).getPropertyValue('cursor');
            if ( event.pageY < 0 ) {
                let windowTopMinus = parseInt(currentWindow.style.top);
                currentWindow.style.height = parseInt(currentWindow.style.height) + windowTopMinus + 'px';
                bordersElement.style.height = parseInt(bordersElement.style.height) + windowTopMinus + 'px';
                windowBodyElement.style.height = parseInt(windowBodyElement.style.height) + windowTopMinus + 'px';
                document.onmouseup();
                currentWindow.style.top = '0px';
                document.querySelector("html").style.userSelect = '';
                outsideAlert('Do more', ghostWindowId);
            } else {
                changeSize(event, item.borderX, item.borderY, item.isPositive);
                moveAt(event, item.moveX, item.moveY);
            }

            // console.log(document.querySelectorAll(".ghost-window"));

            if ( parseInt(currentWindow.style.top) <= 0 && clickedClass === 'window-border-top' ||
                 parseInt(currentWindow.style.top) <= 0 && clickedClass === 'window-border-top-right' 
            ) { // top border
                console.log('top border');
                showGhost({
                    id       : ghostWindowId,
                    width    : currentWindow.offsetWidth,
                    height   : defaultGhostH,
                    posLeft  : event.pageX,
                    posTop   : event.pageY,
                    fromTo   : true,
                    toIfExist: true,
                    posToLeft: parseInt(currentWindow.style.left) - bordersWidth - 2,
                    posToTop : 0
                });
            } else if ( pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom' ||
                        pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom-left'
            ) { // bottom border
                console.log('bottom border');
                showGhost({
                    id       : ghostWindowId,
                    width    : currentWindow.offsetWidth,
                    height   : defaultGhostH,
                    posLeft  : event.pageX,
                    posTop   : event.pageY,
                    fromTo   : true,
                    toIfExist: true,
                    posToLeft: parseInt(currentWindow.style.left) - bordersWidth - 2,
                    posToTop : 0
                });
            } else if ( pxsToTaskBar <= 0 && clickedClass === 'window-border-bottom-right' ||
                        parseInt(currentWindow.style.left) <= 0 ) {
                
                // console.log(clickedClass);
                // console.log(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--default-transition')));
                showGhost({
                    id       : ghostWindowId,
                    width    : currentWindow.offsetWidth,
                    height   : defaultGhostH,
                    posLeft  : usableWidth - event.pageX,
                    posBott  : 70,
                    fromTo   : true,
                    toIfExist: true,
                    posToLeft: usableWidth - parseInt(currentWindow.style.left) - currentWindow.offsetWidth - bordersWidth - 2,
                    posToBott : 0,
                    instantTrans: true,
                    useBottom: true
                });
            } else {
                clearGhosts();
            }





        }
        document.onmouseup = function() {
            console.log(1111111111);
            if ( document.getElementById("style-to-all") ) document.getElementById("style-to-all").remove();
            document.onmousemove = null;
            document.onmouseup = null;
            firstTarget = '';
            console.log(currentWindow.style.top);
            if ( parseInt(currentWindow.style.top) < 0 ) currentWindow.style.top = '0px';
            clearGhosts();
            setTimeout(() => {
                bordersElement.style.transition = '';
                windowBodyElement.style.transition = '';
            }, 10);
            document.querySelector("html").style.cursor = '';
            taskbarOverlay.style.zIndex = '';
            cancel();
            return false;
        }
    });

    document.ondragstart = function() {
        return false;
    }
}

function outsideAlert( message = 'Your mouse outside document, switch to fullscren mode?', id = 1,  ) {
    if ( !window.screenTop && !window.screenY ) {
        setTimeout(() => {
            // removeGhostWindow(ghostWindowId);
            clearGhosts();
            if ( !window.screenTop && !window.screenY && confirm(message) ) document.documentElement.requestFullscreen();
        }, 10);
    }
}


//

// main menu opening
function toggleMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    if ( menuWrap.classList.contains("active") ) {
        menuWrap.classList.remove("active");
        menuWrap.style.left = '30px';
        document.getElementById("button-toggle").style.top = '0';
    } else {
        menuWrap.classList.add("active");
        menuWrap.style.left = '21px';
        document.getElementById("button-toggle").style.top = '-1.7em';
    }
    // blockClicked( menuWrap, 750);
};
// hang menu opening
forEachClick({
    selector: "#open-tasks",
    func: toggleMainMenu,
    needTimeOut: true,
    secTimeOut: parseFloat( getComputedStyle(document.documentElement).getPropertyValue('--default-transition') ) * 1000,
    selectorToBlocked: "#menu-wrap"
    });
//

// main menu closing
function closeMainMenu ( event = {} ) {
    let menuWrap = document.getElementById("menu-wrap");
    
    menuWrap.classList.remove("active");
    menuWrap.style.left = '30px';
    document.getElementById("button-toggle").style.top = '0';
};

setOutsideClick ('#menu-wrap', '#menu-wrap', closeMainMenu);

//

// set margins inside taskbar
function setTasksMargin ( elementToRemove = {} ) {
    let taskbarItems = document.querySelectorAll(".taskbar-item"),
        taskbarItemsCount = taskbarItems.length,
        taskbarItemsWidth = [...taskbarItems].reduce( (prev, current) => prev + current.offsetWidth, 0 ) ,
        taskbarInnerWidth = document.getElementById("taskbar-inner").clientWidth,
        itemsMargin = (taskbarInnerWidth - taskbarItemsWidth) / ( 2*taskbarItemsCount )
    ;

    itemsMargin < 10 ? itemsMargin = 10 : false;

    let reduce = [...taskbarItems].reduce( (left, current) => {
        current.style.left = `${left}px`;
        return left + current.offsetWidth + itemsMargin*2;
    
    }, itemsMargin );
}
//

// moving menu to starting position
function initializeMenu () {
    let menuWrap = document.getElementById("menu-wrap"),
        menuListHeight = document.getElementById("task-list").clientHeight
    ;
    menuWrap.style.bottom = `-${menuListHeight + 3}px`;
}
//

// window focus in
function focusInWindow ( element = {}) {
    element.classList.add("active");
    element.style.zIndex = currentZindex++;
}
//

// window focus out
function focusOutWindow ( activeElement = {} ) {
    document.querySelector(".window-green.active").classList.remove("active");
}
//

// activate task in taskbar
function activateTaskInTaskbar ( elementAttribute = '' ) {
    let element = document.querySelector(`.taskbar-item[task-id="${elementAttribute}"]`);
    if ( element ) {
        element.classList.add("active");
    } else {
        console.error('U dont have task on taskbar to activate!');
    }
}
//

// remove class "active" from elemen with 'selector'
function deactivate ( selector = '' || {} ) {

    if ( typeof selector === "string" ) {
        let activeItem = document.querySelector(selector);
        if ( activeItem ) {
            activeItem.classList.remove('active');
        }
    } else if ( typeof selector === "object" ) {
        selector.classList.remove('active');
    } else {
        console.error('Use me better, i know u can!');
    }
}
//

// doing focus on window
function focusWindow ( element = {} , event ) {
    let activeElement = document.querySelector(".window-green.active");

    if (activeElement) focusOutWindow(activeElement);
    deactivate('.taskbar-item.active');
    if ( event ) {
        if ( event.target.classList.contains('window-minimize') ||
             event.target.classList.contains('minimize-1') ||
             event.target.classList.contains('minimize-2') ||
             event.target.classList.contains('window-close') ||
             event.target.classList.contains('close-line1') ||
             event.target.classList.contains('close-line2')
            ) {
            return;

        }
    }
    if ( element.classList.contains("active") ) {
        return false;
    }
    activateTaskInTaskbar(element.getAttribute('task-id'));
    focusInWindow(element);

}
//

// focusing window from click on taskbar element
function focusWindowFromTB ( element = {} ) {
    let window = document.querySelector(`.window-green[task-id="${element.getAttribute('task-id')}"]`);

    if ( element.classList.contains("active") && window.classList.contains("active") ) {
        return false;
    }
    
    if ( window.classList.contains("minimized") ) maximizeWindow(window);
    focusWindow(window);
}
//

// imagine this is responses like graphQL (but in files)
const jsonMenuItemsData = JSON.parse(jsonMenuItemsResponse);
const jsonWindowItemsData = JSON.parse(jsonWindowItemsResponse); // here all results for simple adding new data in file
//

// jsonWindowItemsData.tasks[0].windowData = `
//             <div class="taskbar-item" task-name="Taskk" task-id="1" style="margin: 0px 139.5px;">
//                 <div class="tpi-title">[ Taskk ]</div>
//             </div>`;

// creating menu items from "service" response
function spawnMenuItems ( jsonMenuItems = {} ) {
    let menuElement = document.getElementById("task-list");
    if (jsonMenuItems) {
        jsonMenuItems.tasks.forEach(function (task) {
            let menuItem = `
                <li class="task-list-item" task-name="${task.name}"  task-id="${task.id}">
                    <div class="task-list-link">${task.name}</div>
                    <div class="task-data">
                    </div>
                </li>
                `;
                menuElement.insertAdjacentHTML('beforeEnd', menuItem);
        });
    } else {
        console.error('jsonMenuItems.tasks is empty');
    }
    // moving menu to starting position
    initializeMenu();
    // hang window handler on taskbar items
    
forEachClick( {selector: ".task-list-item",func: callWindow} );
}
//

function removeMenuItem ( element = {}, menu = {} ) {
    let styles = window.getComputedStyle(element),
        elementFullHeight = element.offsetHeight + parseInt(styles.marginTop),
        menuBottom = parseInt(menu.style.bottom) + elementFullHeight - 2,
        menuTransition = menu.style.transition;
    ;
    element.style.transition = '0.75s';
    element.style.height = element.clientHeight + 'px';
    menu.style.bottom = menuBottom + 'px';
    // menu.style.bottom = -3 - parseInt(document.getElementById("task-list").offsetHeight) + 'px';

    function animation1() {
        return new Promise(resolve => {
            setTimeout(() => {
                element.style.overflow = 'hidden';
                element.style.margin = '0px';
                element.style.transform = 'scale(0)'; 
                element.style.height = '0';
                menu.style.transition = '1s';
                document.getElementById('open-tasks').click();
                // console.log('a');
                resolve("animation1!");
            }, 0);
        });
    }
    function animation2() {
        return new Promise(resolve => {
            setTimeout(() => {
                menu.style.transition = menuTransition;
                // console.log('b');
                resolve("animation2!");
            }, 750);
        });
    }
    function animation3() {
        return new Promise(resolve => {
            element.classList.add('hidden');
            if ( menu.getElementsByTagName('ul')[0].getElementsByTagName('li').length == menu.getElementsByTagName('ul')[0].querySelectorAll(".hidden").length ) {
                console.log('No tasks');
                let menuStyles = window.getComputedStyle(menu),
                    menuML = menuStyles.marginLeft;
                
                setTimeout(() => {
                    menu.style.marginLeft = menuML;
                }, 0);
                setTimeout(() => {
                    menu.style.bottom = '-500px';
                    document.getElementById("taskbar").style.right = (window.innerWidth - document.getElementById('taskbar').offsetWidth) / 2 + 'px';
                    document.getElementById("taskbar").style.transition = '1s';
                }, 10);
                    console.log(menuML);
            }
            
            resolve("animation3!");
        });
    }

    async function animateAll() {
        let result1 = await animation1(),
            result2 = await animation2(),
            result3 = await animation3();
    }
    animateAll();

}


// spawn window on click menu item
function callWindow ( element = {} ) {
    let taskId = element.getAttribute('task-id'),
        menuBox = document.getElementById('menu-wrap'),
        windowData = jsonWindowItemsData.tasks[taskId-1], // like response
        functionsToInit = windowData.functionsToInit,
        transition = getComputedStyle(document.documentElement).getPropertyValue('--fast-transition'),
        widowActive = document.querySelector(".window-green.active")
    ;
    console.log(windowData);
    
        removeMenuItem(element, menuBox);
        
        let newWindow = spawnHtml( prepareWindow(windowData) );
        setWindowOnCenter(newWindow);
        
        if (functionsToInit) functionsToInit.forEach(function(functionToInit) {
            functionsToInitWindow[functionToInit]();
        });

        spawnTask(windowData);
        deactivate('.taskbar-item.active');
        activateTaskInTaskbar(taskId);

        if (widowActive) widowActive.classList.remove("active");
        newWindow.classList.add("active");
            
        forEachClick( {selector: ".window-green.unhanged",func: focusWindow} );
        // forEachFunc(".window-green.unhanged", windowResize);
        forEachClick( {selector: ".window-close.unhanged",func: closeWindow} );
        forEachClick( {selector: ".window-minimize.unhanged",func: minimizeWindow} );
        document.querySelector(".window-close.unhanged").classList.remove("unhanged");
        document.querySelector(".window-minimize.unhanged").classList.remove("unhanged");
        forEachFunc(".window-head.unhanged", windowsDraging);
        document.querySelector(".window-head.unhanged").classList.remove("unhanged");
        newWindow.getElementsByClassName("window-borders")[0].style.width = newWindow.offsetWidth + 'px';
        newWindow.getElementsByClassName("window-borders")[0].style.height = newWindow.offsetHeight + 'px';
        
        transformAnimation({
            element: newWindow,
            transition: transition,
            transitionEnd: 'none',
            transformFrom: 'scale(0)',
            transformTo:  'scale(1)',
            classToRemove: 'unhanged',
            transformEnd: 'unset',
            // test: '12142'
        });

        if ( document.querySelectorAll(".taskbar-item").length < 2 ) {
            setTimeout(() => {
                setTasksMargin();
            }, 5);
        } else {
            setTasksMargin();
        }

}
//

// spawning window
function prepareWindow ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        windowId = taskName.toLowerCase().replace( ' ', '-'),
        windowSizeClass = windowObj.windowSizeClass,
        windowBodyStyles = windowObj.windowBodyStyles,
        individualStyles = windowObj.individualStyles,
        stylesHTML = '<style></style>'
        windowData = windowObj.windowData,
        selector = ".window-green.unhanged",
        classHTML = "window-green unhanged"
    ;
    
    if (individualStyles) individualStyles.forEach(function(element) {
        stylesHTML = stylesHTML.replaceAll( '</', `#${windowId} ${element} </` );
    });
    let windowHTML = `
            <div id="${windowId}" class="${classHTML}" task-name="${taskName}" task-id="${taskId}" style="z-index: ${currentZindex++};">
                <div class="window-main">
                    <div class="window-top">
                        <div class="window-minimize unhanged">
                            <div class="minimize-1"></div>
                            <div class="minimize-2"></div>
                        </div>
                        <div class="window-close unhanged">
                            <div class="close-line1"></div>
                            <div class="close-line2"></div>
                        </div>
                        <div class="window-line"></div>
                    </div>
                    <div class="window-head unhanged"><div class="wh-header">[ ${taskName} ]</div></div>
                    <div class="window-body ${windowSizeClass}" style="${windowBodyStyles}">
                        ${stylesHTML}
                        ${windowData}
                    </div>
                </div>
                <div class="window-borders">
                    <div class="window-border-top">
                        <div class="window-border-top-right"></div>
                    </div>
                    <div class="window-border-bottom">
                        <div class="window-border-bottom-left"></div>
                    </div>
                    <div class="window-border-left"></div>
                    <div class="window-border-right"></div>
                    <div class="window-border-top-left"></div>
                    <div class="window-border-bottom-right"></div>
                </div>
            </div>
        `;
    return [windowHTML, selector];
}
//

// spawning task in taskbar
function spawnTask ( windowObj = {} ) {
    let taskId = windowObj.id,
        taskName = windowObj.name,
        elementHTML = `
            <div class="taskbar-item unhanged" style="left:-250px" task-name="${taskName}" task-id="${taskId}">
                <div class="tpi-title">[ ${taskName} ]</div>
            </div>
        `;
    if ( !document.querySelectorAll(".taskbar-item.unhanged")[0] ) {
        document.querySelectorAll(".taskbar-item-empty")[0].style.opacity = 0;
    }
        document.getElementById('taskbar-inner').insertAdjacentHTML('afterBegin', elementHTML);
    let newTask = document.querySelectorAll(".taskbar-item.unhanged")[0] ;
        forEachClick( {selector: ".taskbar-item.unhanged",func: focusWindowFromTB} );
        newTask.classList.remove("unhanged");

    return newTask;
    
}
//




// functions to render page
// forEachClick( {selector: ".window-close",func: closeWindow} );

// hang window focus handler on window
// forEachClick( {selector: ".window-green",func: focusWindow} );
//

// // hang window focus handler on taskbar item
// forEachClick( {selector: ".taskbar-item",func: focusWindowFromTB} );
// //

// spawnRadar(radarToDecard(spawnRadarVals(5)));

spawnMenuItems(jsonMenuItemsData);

// setTasksMargin();
//










setTimeout(() => {
    document.querySelectorAll(".task-list-item")[0].click();
}, 250);

// setTimeout(() => {
//     document.querySelectorAll(".task-list-item")[0].click();
// }, 820);


</script>
<script>
    // inputting code in highlighted window
    // document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    // console.log( document.getElementById("main-script").innerHTML );
    
function initHighlitedText( number = 5 ) {
    
    // inputting code in highlighted window
    document.getElementById("code-wrap").append(document.getElementById("main-script").innerHTML);
    hljs.highlightAll();
}
functionsToInitWindow['initHighlitedText'] = initHighlitedText;
//
</script>
<link rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/styles/atom-one-dark.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.3.1/build/highlight.min.js"></script>

</body>
</html>